\documentclass[12pt]{article}

\usepackage{graphicx,caption,svg}
\usepackage[utf8]{inputenc}

\renewcommand{\contentsname}{Indice}
\setlength{\parindent}{0pt}

\def \Euno {Allegati/Esercizio1/}
\def \Edue {Allegati/Esercizio2/}
\def \Etre {Allegati/Esercizio3/}
\def \Equattro {Allegati/Esercizio4/}
\def \Ecinque {Allegati/Esercizio5/}
\def \Esei {Allegati/Esercizio6/}
\def \Esette {Allegati/Esercizio7/}
\def \Eotto {Allegati/Esercizio8/}
\def \Enove {Allegati/Esercizio9/}
\def \Edieci {Allegati/Esercizio10/}
\def \Eundici{Allegati/Esercizio11/}
\def \Edodici {Allegati/Esercizio12/}


\begin{document}

\title{Tesina Architettura dei Sistemi Digitali}
\date{\today}
\tableofcontents
\newpage
\section{Esercizio 1 - Multiplexer}
\subsection{Parte 1}
L’esercizio 1.1 richiede la rappresentazione di un multiplexer 16:1 tramite la composizione di multiplexer 4:1, quindi definiamo il module del componente mux\_4\_1 definito in modo Dataflow, e poi per le proprietà della modularità definiamo il module mux\_16\_1 come composizione dei precedenti, tramite il costrutto \textit{for..generate}.


Il multiplexer 4:1 ha come ingressi quattro bit, identificati col vettore a(0 to 3), e $\lceil \log_{2}(n) \rceil$ segnali di abilitazione, dove n è il numero di segnali di ingresso. In questo caso, quindi, due segnali di abilitazione ed uno di uscita.
\begin{figure}[ht]
    \centering
    \includesvg[width=\textwidth,height=0.2\textheight]{\Euno mux_4_1.svg}
    \caption{Mux 4:1}
\end{figure}

Il codice in VHDL per descrivere il comportamento di questo componente è il seguente:
\begin{figure}[ht]
    \centering
    \includegraphics[width=\textwidth,height=0.3\textheight,keepaspectratio]{\Euno mux_4_1_dataflow.png}
    \caption{Mux 4:1 Dataflow}
\end{figure}

Composto da un costrutto \textit{when...else} che suddivide i diversi casi e gestisce anche tutti i casi non definiti con l’ultima clausola else senza alcuna condizione.

Definito l’elemento base del progetto, si passa a comporre il multiplexer 16:1 tramite un approccio strutturale, nel quale generiamo cinque mux\_4\_1: i primi quattro avranno gli ingressi interfacciati con l’esterno e, tramite segnali interni, le loro uscite sono collegate come ingressi dell’ultimo multiplexer che costituisce  l’uscita del sistema.
La macchina completa presenta quindi 16 segnali di ingresso, 4 segnali di selezione ed un unico segnale di uscita:

\begin{figure}[ht]
    \centering
    \includesvg[width=\textwidth,height=0.65\textheight]{\Euno mux_16_1.svg}
    \caption{Mux 16:1}
\end{figure}
\newpage
Lo schema sopra rappresentato è tradotto in linguaggio VHDL dal seguente codice, dove l’entità mux\_16\_1 è rappresentata con approccio strutturale e, tramite i segnali interni c(0 to 3), colleghiamo le uscite parziali dei primi quattro mux\_4\_1, identificati con la label mux\_4\_1\_in, con i quattro ingressi dell’ultimo mux\_4\_1, identificato con la label mux\_4\_1\_fin.
\begin{figure}[ht]
    \centering
    \includegraphics[width=1.3\textwidth,height=0.6\textheight,keepaspectratio]{\Euno mux_16_4_structural.png}
    \caption{Mux 16:1 Dataflow}
\end{figure}
\newpage
Progettato il mux\_16\_1, è possibile testarlo attraverso un testbench. La prima cosa che bisogna specificare è che il corpo dell’entity è vuoto, questo perché non si tratta di oggetto che realizziamo, ma serve solo per effettuare la simulazione e verificare se il sistema realizzato funziona correttamente. Il testbench effettivamente non ha né segnali d’ingresso né d’uscita, ma sfrutta per i test i segnali interni definiti nel codice. Per testare il mux\_16\_1 definito precedentemente, abbiamo istanziato una uut (Unit
Under Test) in cui colleghiamo le varie porte ai segnali (input, selection, output).\newline
\begin{figure}[h]
    \centering
    \includegraphics[width=1.2\textwidth,height=0.6\textheight,keepaspectratio]{\Euno mux_16_1_tb.png}
    \caption{Mux 16:1 Testbench}
\end{figure}
\newpage Dopo aver effettuato queste assegnazioni, compreso di costrutto after per permettere l’evoluzione del sistema durante il tempo, si passa alla schermata di simulazione nella quale si può analizzare e studiare l’evoluzione nel tempo di ogni segnale presente nel codice, compresi eventuali segnali intermedi.
\begin{figure}[ht]
    \centering
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Euno mux_16_1_simulazione.png}
    \caption{Mux 16:1 Simulazione}
\end{figure}
\newline Possiamo analizzare l’evoluzione del programma:
dopo circa 150ns, l’ingresso è posto a “0000000000000001” e contemporaneamente la selezione è posta a “1111”, ottenendo come uscita del sistema “1”. Questo è effettivamente il comportamento atteso.
\newpage


\subsection{Parte 2}
L’esercizio 1.2 è in parte riconducibile all’esercizio precedente, in quanto la rappresentazione di una rete 16:4 può essere scomposta da una sottorete 16:1 connessa ad un demux 1:4. Basta quindi aggiungere un demultiplexer 1:4 alla rete precedente. Il demux 1:4 è realizzato con approccio Dataflow.
\begin{figure}[ht]
    \centering
    \includegraphics[width=0.8\textwidth,height=\textheight,keepaspectratio]{\Euno demux_4_1_dataflow.png}
    \caption{Demux 1:4 Dataflow}
\end{figure}
\newline Il Demux 1:4 presenta come uscita un segnale di 4 bit, di cui 3 pari a zero ed uno pari al valore in ingresso, la cui posizione è determinata a seconda dei segnali di abilitazione.
\begin{figure}[ht]
    \centering
    \includesvg[width=\textwidth,height=0.4\textheight]{\Euno rete_16_4.svg}
    \caption{Rete 16:1}
\end{figure}
\newpage
Una volta eseguite le interconnessioni tramite un unico segnale interno, utilizzato per collegare l’uscita del mux\_16\_1 con l’ingresso del demux\_1\_4, si ottiene la rete 16:4:  tale rete presenta 16 segnali di ingressi totali, 6 di selezione (di cui 2 utilizzati per il demux) e 4 segnali di uscita.
\begin{figure}[ht]
    \centering
    \includegraphics[width=0.8\textwidth,height=\textheight,keepaspectratio]{\Euno rete_16_4_structural.png}
    \caption{Rete 16:4 Structural}
\end{figure}
\\
Anche dopo aver testato il singolo componente, è comunque necessario ripetere il test per la macchina completa, sia perché potrebbero essere presenti errori e problemi derivanti da implementazione di nuove funzioni, sia perché anche nella composizione di una macchina più complessa sono presenti intrinsecamente problemi legati alla coesione dei vari moduli.
\newpage
\begin{figure}[ht]
    \centering
    \includegraphics[width=0.4\textwidth,height=\textheight,keepaspectratio]{\Euno rete_16_4_tb.png}
    \caption{Rete 16:4 Testbench}
\end{figure}

\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.7\textwidth,height=\textheight,keepaspectratio]{\Euno rete_16_4_simulazione.png}
    \caption{Rete 16:4 Simulazione}
\end{figure}
\newpage

\subsection{Parte 3}
Come esercizio finale, è stato necessario adattare la rete per la sintesi sulla FPGA. Attraverso l’utilizzo di un file di constraint ideato per la board Nexys A7-50t, possiamo definire i collegamenti da effettuare sulla scheda tra le diverse periferiche disponibili e le componenti presenti all’interno della rete.
\newline
In questo caso sono necessari 6 switch per le linee di abilitazione dei multiplexer e demultiplexer. Poichè gli switch sono in totale 16, è stato necessario dare un input predefinito alla rete ed utilizzare gli switch unicamente per la selezione.
Inoltre, sempre dal file di costraint, sono stati abilitati anche 4 led e connessi ai quattro bit di uscita, come indicato nel seguente file.
\begin{figure}[ht]
    \centering
    \includegraphics[width=0.7\textwidth,height=\textheight,keepaspectratio]{\Euno costraints_es1.png}
    \caption{Costraints}
\end{figure}
\\Quindi, gli switch \textbf{\textit{J15-L16-M13-R15}} sono stati mappati ai quattro bit di selezione dei multiplexer, mentre gli switch \textbf{\textit{R17-T18}} ai due bit di selezione dei multiplexer, ed, infine, i led H17-K15-J13-N14 come rappresentazione visiva dei quattro bit di uscita al sistema complessivo.
\newline
Il sistema finale è quello raffigurato nella seguente figura
\begin{figure}[ht]
    \centering
    \includegraphics[width=0.8\textwidth,height=\textheight,keepaspectratio]{\Euno rete_16_4_analysis.png}
    \caption{Rete 16:4 Analysis}
\end{figure}


\newpage
\section{Esercizio 2 - Encoder BCD}
\subsection{Traccia}

Progettare, implementare in VHDL e testare mediante simulazione una rete che, data in ingresso una stringa binaria X di 10 bit X9 X8 X7 X6 X5 X4 X3 X2 X1 X0 che corrisponde alla rappresentazione decodificata di una cifra decimale (cioè, una rappresentazione in cui ogni stringa contiene un solo bit alto), fornisce in uscita la rappresentazione Y della cifra mediante codifica Binary-Coded Decimali (BCD).
\\Input: 0000000001 $\Rightarrow$ Output: 0000 (cifra 0)
\\Input: 0000000010 $\Rightarrow$ Output: 0001 (cifra 1)
\\Input: 0000000100 $\Rightarrow$ Output: 0010 (cifra 2)
\\....
\\Sintetizzare ed implementare su board il progetto dell’encoder BCD utilizzando gli switch per fornire la stringa X in ingresso, e i led per visualizzare Y. Nel caso in cui si utilizzi una board dotata di soli 8 switch, è possibile sviluppare il progetto considerando X di soli 8 bit (la macchina sarà allora in grado di fornire in uscita la rappresentazione BCD delle cifre decimali da 0 a 7).
\\Utilizzare un display a 7 segmenti per visualizzare la cifra decimale codificata da Y (pilotare opportunamente i catodi del display per visualizzare la cifra).
\subsection{Soluzione}
La rete è stata realizzata con vari componenti secondo un approccio strutturale. Essa ha un ingresso, cioè il valore della stringa X da 10 bit, e 2 uscite, utili per visualizzare la cifra codificata su un display a 7 segmenti.
La rete utilizza i seguenti componenti:
\begin{itemize}
    \item Un encoder: a sua volta composto da un arbitro a priorità e da un encoder 10:4;
    \item Un display manager per la visualizzazione dell’output;
\end{itemize}
Si è partiti, dunque, da una descrizione dataflow dei componenti base, per poi procedere con una descrizione strutturale dell’encoder ed una descrizione comportamentale del display manager. Infine, mettendo insieme questi ultimi 2 componenti, si è descritto l’intero sistema, chiaramente a livello strutturale.

    {\large  \textbf{Arbitro a priorità:}}
\\Il componente relativo all’arbitro di priorità dispone di un vettore di ingresso di 10 bit e di un vettore di uscita di altrettanti bit, in cui l’uscita avrà tutti 0 e un solo bit alto nella prima posizione in cui è stato trovato un 1 (a partire dalla posizione più significativa).
\\\\{\large \textbf{Encoder 10:4:}}
\\Il componente relativo all’encoder 10:4 presenta in ingresso un vettore di 10 bit ed in uscita un vettore di 4 bit, che rappresenta il numero in binario della prima posizione con bit alto in ingresso (valore compreso nel range [0,9]).
\\\\Facendo uso dei due componenti appena descritti, si è realizzato un encoder, il quale facendo uso di un segnale interno che fa da interconnessione tra l’uscita dell’arbitro e l’ingresso dell’encoder 10:4, prende in ingresso un vettore di 10 bit e restituisce in uscita un vettore di 4 bit effettuando la codifica Binary-Coded Decimal (BCD).
\\\\{\large \textbf{Display Manager:}}
\\Il componente display manager prende in ingresso un vettore di 4 bit e lo rappresenta sul display a 7 segmenti con 2 uscite. Al suo interno vengono definite delle costanti su 7 bit relative ai segmenti di una cifra del display da illuminare, in questo modo si visualizza un determinato valore in esadecimale. La prima uscita è fissa, al fine di illuminare costantemente solo la prima cifra del display, poiché il valore da mostrare è rappresentabile con una sola cifra. La seconda uscita determina i segmenti della cifra da illuminare, pertanto dipende dall’ingresso.
\\La rete complessiva dispone dell’encoder e del display manager. Il vettore di ingresso di 10 bit andrà nell’encoder e la sua uscita su 4 bit, mediante un segnale di interconnessione, andrà in ingresso al display manager che mostra il valore di uscita sul display.
\newpage
\subsection{Codice}
{\large \textbf{Arbitro}}
\\L’architettura è stata descritta a livello dataflow e, scorrendo un vettore a partire dalla posizione 9 fino a 0, se tra i 10 bit uno solo è alto, l’uscità sarà una stringa con tutti 0 e solo un bit alto nella posizione in cui lo era nel vettore di ingresso. Nel caso in cui il vettore di ingresso presenta più bit uguali a 1, la stringa in uscita avrà il solo bit alto nella prima posizione, partendo dalla 9, in cui trova un 1.
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.7\textwidth,height=\textheight,keepaspectratio]{\Edue codice_arbitro.jpg}
    \caption{Codice Arbitro}
\end{figure}
\newpage
{\large \textbf{Encoder 10:4}}

L’encoder 10:4 è stato descritto a livello dataflow. L’architettura, partendo da un vettore con solo un bit alto, restituisce in uscita il valore su 4 bit della posizione in cui il bit è alto.
\begin{figure}[ht]
    \centering
    \includegraphics[width=0.6\textwidth,height=\textheight,keepaspectratio]{\Edue codice_encoder10_4.jpg}
    \caption{Codice Encoder 10:4}
\end{figure}
\newpage
{\large \textbf{Encoder complessivo}}
\\L’encoder complessivo è descritto a livello strutturale utilizzando i componenti “arbitro” e “encoder10\_4”. All’interno del sistema è definito un segnale t di tipo std\_logic\_vector(9 downto 0), che fa da interconnessione e viene utilizzato come uscita dell’arbitro e come ingresso dell’encoder 10:4.
\begin{figure}[ht]
    \centering
    \includegraphics[width=0.6\textwidth,height=\textheight,keepaspectratio]{\Edue codice_encoder_parte1.jpg}
\end{figure}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.5\textwidth,height=\textheight,keepaspectratio]{\Edue codice_encoder_parte2.jpg}
    \caption{Codice Encoder Complessivo}
\end{figure}
\newpage
{\large \textbf{Display Manager}}
\begin{figure}[ht]
    \centering
    \includegraphics[width=0.2\textwidth,height=\textheight,keepaspectratio]{\Edue display.jpg}
    \caption{Display Segment}
\end{figure}
\newline
Questo componente viene descritto a livello comportamentale. Viene definita l’entity con una porta in ingresso, value, e due porte in uscita, anode e cathode, tutte di tipo std\_logic\_vector. Nel costrutto architecture sono definite delle costanti di 7 bit, dove la posizione rappresenta un segmento di una cifra del display: quando il bit è 0 il segmento è acceso, altrimenti è spento. Poiché il valore è in notazione esadecimale, sono state definite le costanti che rappresentano i valori da 0 a f. Per tenere accesa solo la prima cifra del display, l’uscita anode viene settata con tutti i bit alti, ad eccezione di quello meno significativo; in questo modo le cifre successive alla prima sono spente. Si usa l’altra uscita, cathode, per rappresentare il valore tramite una AND tra ‘1’ e la costante che rappresenta il valore da mostrare a video.
\begin{figure}[ht]
    \centering
    \includegraphics[width=0.9\textwidth,height=\textheight,keepaspectratio]{\Edue codice_display_manager_parte1.jpg}
\end{figure}
\begin{figure}[ht]
    \centering
    \includegraphics[width=0.8\textwidth,height=\textheight,keepaspectratio]{\Edue codice_display_manager_parte2.jpg}
\end{figure}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.9\textwidth,height=\textheight,keepaspectratio]{\Edue codice_display_manager_parte3.jpg}
    \caption{Codice Display Manager}
\end{figure}
\newpage
{\large \textbf{Sistema Completo}}
\\Nella descrizione strutturale dell’architettura si definiscono i componenti encoder, quello complessivo, e display manager e si definisce un segnale interno temp, di tipo std\_logic\_vector, che fa da interconnessione tra l’uscita dell’encoder e l’ingresso del display manager, al fine di rappresentare a video l’output dell’encoder.
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.5\textwidth,height=\textheight,keepaspectratio]{\Edue codice_sistema_completo_parte1.jpg}
\end{figure}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.5\textwidth,height=\textheight,keepaspectratio]{\Edue codice_sistema_completo_parte2.jpg}
\end{figure}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.4\textwidth,height=\textheight,keepaspectratio]{\Edue codice_sistema_completo_parte3.jpg}
    \caption{Codice Sistema Completo}
\end{figure}
\subsection{Simulazione}
Per effettuare la simulazione è stato utilizzato il seguente testbench per l’encoder:
\begin{figure}[ht]
    \centering
    \includegraphics[width=0.6\textwidth,height=\textheight,keepaspectratio]{\Edue sim1.jpg}
\end{figure}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.6\textwidth,height=\textheight,keepaspectratio]{\Edue sim2.jpg}
    \caption{Codice Testbench}
\end{figure}
\begin{figure}[ht]
    \centering
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Edue simulazione_encoder.jpg}
    \caption{Simulazione Encoder}
\end{figure}
\clearpage
\section{Esercizio 3 - Riconoscitore di Sequenze}
\subsection{Traccia}
Progettare, implementare in VHDL e testare mediante simulazione una macchina in grado di riconoscere la sequenza 1001. La macchina prende in ingresso un segnale binario i che rappresenta il dato, un segnale A di tempificazione e un segnale M di modo, che ne disciplina il funzionamento, e fornisce un’uscita Y alta quando la sequenza viene riconosciuta. In particolare,
\begin{itemize}
    \item se M=0, la macchina valuta i bit seriali in ingresso a gruppi di 4,
    \item se M=1, la macchina valuta i bit seriali in ingresso uno alla volta, tornando allo stato iniziale ogni volta che la sequenza viene correttamente riconosciuta.
\end{itemize}
Sintetizzare e implementare su board la rete sviluppata al punto precedente, utilizzando uno switch S1 per codificare l’input i e uno switch S2 per codificare il modo M, in combinazione con due bottoni B1 e B2 utilizzati rispettivamente per acquisire l’input da S1 e S2 in sincronismo con il segnale di tempificazione A, che deve essere ottenuto a partire dal clock della board. Infine, l’uscita Y può essere codificata utilizzando un led.
\subsection{Soluzione}

La macchina realizzata è un riconoscitore che, in base al modo stabilito, riconosce la sequenza 1001. Pertanto, il riconoscitore viene descritto a livello strutturale e dispone di 3 componenti:
\begin{itemize}
    \item Il debouncer (descritto a livello comportamentale);
    \item Un gestore per il modo (descritto a livello strutturale);
    \item Il sistema che si occupa del riconoscimento vero e proprio (descritto a livello comportamentale).
\end{itemize}
\newpage
{\large \textbf{Sistema per il riconoscimento}}

Il sistema che effettua il riconoscimento viene descritto a livello comportamentale.
\begin{figure}[ht]
    \centering
    \includegraphics[width=0.7\textwidth,height=\textheight,keepaspectratio]{\Etre codice_sistema_parte1.png}
    \caption{Codice Sistema Pt1}
\end{figure}
\\Nella descrizione è definito un tipo enumerativo “status” che contiene tutti i possibili stati della macchina: S0, S1, S2, S3, S4, S5, S6, S7. Per quanto riguarda il modo, nello specifico, se M=1 vengono considerati i primi 5 stati, se M=0 vengono considerati tutti.
Tra questi, lo stato S4 viene raggiunto se la sequenza 1001 è stata riconosciuta.
Il comportamento della macchina è definito da un process sensibile al clock:
Se il segnale di RESET è alto, allora resetta lo stato corrente della macchina, riportandolo a S0, e permette di acquisire il nuovo modo M.
Se M=1,
\begin{itemize}
    \item Stato S0: se si riceve in ingresso 0, si permane in S0; se si riceve 1, si va in S1, poiché è stato riconosciuto un 1 (prima cifra della sequenza cercata);
    \item Stato S1: se si riceve 1, si permane in S1, poiché non è la prossima cifra cercata, ma l’ultima trovata è un 1; se si riceve 0, si va in S2 ed è stata riconosciuta la sequenza 10;
    \item Stato S2: se si riceve 1, si ritorna in S1; se si riceve 0, si va in S3 ed è stata riconosciuta 100;
    \item Stato S3: se si riceve 0, si ritorna in S0, poiché sarebbe stata riconosciuta la sequenza 1000, che non è quella che si ricercava; se si riceve 1, si va in S4 e si riconosce proprio la sequenza 1001.
\end{itemize}
Se M=0, c’è un concetto di conteggio su 4 bit, pertanto anche in caso di valore non ricercato in ingresso, si procede in avanti verso altri stati. Nello specifico,
\begin{itemize}
    \item Stato S0: se si riceve 1, come prima si va in S1; altrimenti si va in S5;
    \item Stato S1: se si riceve 0, si va in S2; altrimenti si va in S6;
    \item Stato S2: se si riceve 0, si va in S3; altrimenti in S7;
    \item Stato S3: se si riceve 1, si va in S4 e la sequenza 1001 è stata riconosciuta; altrimenti si torna in S0 perché su 4 bit è stata riconosciuta la sequenza 1000, che non è quella cercata.
\end{itemize}
Per gli stati successivi non importa il bit ricevuto in ingresso, in quanto a gruppi di 4 bit alla volta non sarebbe riconosciuta la sequenza ricercata, pertanto
\begin{itemize}
    \item Stato S5: va in S6;
    \item Stato S6: va in S7;
    \item Stato S7: va in S0.
\end{itemize}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=\textwidth,height=0.4\textheight,keepaspectratio]{\Etre codice_sistema_parte2.png}
\end{figure}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=\textwidth,height=0.55\textheight,keepaspectratio]{\Etre codice_sistema_parte3.png}
\end{figure}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=\textwidth,height=0.3\textheight,keepaspectratio]{\Etre codice_sistema_parte4.png}
    \caption{Codice Sistema Pt2}
\end{figure}
\clearpage
{\large \textbf{Debouncer}}
\\Tale componente ha il compito di trasformare un segnale rumoroso in un segnale pulito. Quando un segnale arriva da un bottone sarà sicuramente effetto da rumore, come riportato in figura. Ad un occhio umano, tali oscillazioni non vengono percepite ma, quando tale segnale viene analizzato ad un microcontrollore, queste vengono rilevate a pieno e potrebbero creare problemi (se tale segnale va in ingresso ad un contatore si traduce in conteggi spuri).
\begin{figure}[ht!]
    \centering
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Etre debouncer.png}
    \caption{Debouncer}
\end{figure}
Il debouncer viene progettato come una macchina a stati:
\begin{itemize}
    \item Stato not pressed: il sistema permane in questo stato finchè non vede il segnale in ingresso alzarsi. Passa così nello stato pressed.
    \item Stato pressed: il sistema permane in questo stato finchè il segnale in ingresso non si abbassa. Quando ciò accade, si utilizza una variabile di conteggio, la quale fa si che passi un periodo di tempo pari a D2 prima di riportare il segnale come alto in uscita e tornare nello stato not pressed.
\end{itemize}
Il segnale in uscita rimane alto per un periodo di clock dato che, quando il sistema ritorna nello stato not pressed, l’uscita viene abbassata nuovamente. A differenza di un debouncer classico, l’uscita viene riportata alta solo dopo che il segnale si è abbassato e non dopo un tempo D1 dal fronte di salita; la scelta è stata fatta poiché, altrimenti, se il bottone venisse premuto troppo a lungo potrebbe essere rilevato nuovamente ed in uscita si produrrebbero 2 segnali puliti invece di 1.
\newpage
{\large \textbf{Filtro per il modo}}

Questo componente prende in ingresso il segnale filtrato dal debouncer, chiamato “cleared\_button”, il clock e l’input dallo switch S2, che rappresenta il modo, e restituisce il modo. Viene descritto a livello comportamentale:  se il bottone B2 è premuto, il modo viene impostato tramite S2.
\begin{figure}[ht]
    \centering
    \includegraphics[width=0.6\textwidth,height=\textheight,keepaspectratio]{\Etre codice_filtro_modo.jpg}
    \caption{Codice filtro modo}
\end{figure}
\\{\large \textbf{Gestore per il modo}}
\\Il componente relativo alla gestione del modo viene descritto a livello strutturale e si compone di un debouncer e di un filtro per il modo. Prende in ingresso il clock, il segnale del bottone B2, l’input dallo switch S2. B2 va in ingresso al debouncer per la pulizia del segnale e l’uscita del debouncer, attraverso il segnale interno cb\_temp va in ingresso al filtro insieme a S2. L’uscita sarà data dal filtro, pertanto sarà il modo, che successivamente sarà dato in ingresso al sistema di riconoscimento.
\begin{figure}[ht]
    \centering
    \includegraphics[width=0.5\textwidth,height=\textheight,keepaspectratio]{\Etre codice_gestore_modo_parte1.jpg}
\end{figure}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=1.1\textwidth,height=0.7\textheight]{\Etre codice_gestore_modo_parte2.jpg}
    \caption{Codice gestore modo}
\end{figure}
\clearpage
{\large \textbf {Riconoscitore}}
\\Il riconoscitore complessivo viene descritto in modo Strutturale tramite i componenti presentati finora.
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.8\textwidth,height=\textheight,keepaspectratio]{\Etre codice_riconoscitore_parte1.jpg}
\end{figure}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.8\textwidth,height=\textheight,keepaspectratio]{\Etre codice_riconoscitore_parte2.jpg}
\end{figure}
\clearpage
\begin{figure}[ht!]
    \centering
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Etre codice_riconoscitore_parte3.jpg}
    \caption{Codice riconoscitore}
\end{figure}
{\large \textbf{Simulazione}}
\\Per la simulazione si è usato il seguente testbench sul riconoscitore completo, compreso di sistema di riconoscimento, debouncer e gestore del modo:
\begin{figure}[ht!]
    \centering
    \includegraphics[width=\textwidth,height=0.15\textheight]{\Etre simulazione_riconoscitore.jpg}
    \caption{Simulazione riconoscitore}
\end{figure}
\newpage
\section{Esercizio 4 - Shift Register}
\subsection{Traccia}
{\large \textbf{Shift register}}
\\L’esercizio richiede la progettazione di uno shift register, mediante un approccio sia comportamentale che strutturale, con le seguenti caratteristiche:
\begin{itemize}
    \item Modo variabile: lo shift register, sulla base di un segnale in ingresso, deve effettuare shift verso destra o verso sinistra.
    \item Shift variabile: sulla base di un segnale in ingresso, il registro deve poter variare il numero di posizioni di shift.
\end{itemize}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Equattro entity_shift.png}
    \caption{Entity Shift Bidirezionale}
\end{figure}
\subsection{Approccio comportamentale}
Per la progettazione di tipo comportamentale è stato utilizzato il costrutto \textit{if}, dato che sia le opzioni di modo che di shift comprendevano solo due possibilità; in un caso più generale, il costrutto case sarebbe più appropriato.
Lo shift register realizzato prevede un ingresso seriale ed un output parallelo, gestiti nel seguente modo:
\begin{itemize}
    \item Ingresso mode: tale segnale varia la modalità di shift: se pari ad 1, il valore viene inserito da destra, altrimenti da sinistra.
    \item Ingresso a: tale segnale funge da abilitazione, ovvero il registro effettua uno shift solo se, sul fronte di salita del clock, rileva un’abilitazione pari ad 1.
    \item Ingresso shift: è il segnale che gestisce il numero di posizioni dello shift: quando è pari a 0, avviene lo shift di una posizione, altrimenti di due.
\end{itemize}
\begin{figure}[ht]
    \centering
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Equattro architecture_shift.png}
    \caption{Architecture Shift Register Bidirezionale}
\end{figure}
\clearpage
\begin{figure}[ht]
    \centering
    \includegraphics[width=0.5\textwidth,height=0.5\textheight,keepaspectratio]{\Equattro architecture_shift_2.png}
\end{figure}
\subsection{Approccio Strutturale}
Per la realizzazione tramite un approccio strutturale, sono stati realizzati dei flip flop D bidirezionali.
\\\\{\large \textbf{Component Ffd\_bidirezionali:}}
\begin{figure}[ht]
    \centering
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Equattro ffd1.png}
    \caption{Entity Flip Flop D}
\end{figure}
\\La logica di tale componente è molto semplice:
\\prevede 2 ingressi (leftInput e RightInput) e, in base al segnale di mode in ingresso, decide quale riportare in uscita. Tale componente è sincrono e lavora solo con abilitazione pari ad 1.
\clearpage
\begin{figure}[ht]
    \centering
    \includegraphics[width=\textwidth,height=0.7\textheight,keepaspectratio]{\Equattro ffd2.png}
    \caption{Architecture Flip Flop D}
\end{figure}
{\large \textbf{Component mux\_2\_1:}}
\\Tale componente è necessario per selezionare quale valore deve essere riportato in ingresso ai flipflop, in base allo shift richiesto.
Dato che lo shift può variare al massimo di una posizione, un multiplexer 2:1 è sufficiente; in un caso più generale, si potrebbe ricorrere ad un multiplexer con un numero maggiore di ingressi.
\clearpage
\begin{figure}[ht]
    \centering
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Equattro mux.png}
    \caption{Mux 2:1}
\end{figure}
Vediamo ora come tali componenti sono stati combinati:
\clearpage
\begin{figure}[ht!]
    \centering
    \includegraphics[width=1\textwidth,height=0.4\textheight]{\Equattro generate.png}
    \caption{ Generate FFD}
\end{figure}
\begin{itemize}
    \item \textbf{PrimoFF:} è il primo flip flop da sinistra, ovvero quello di posizione 1. È stato differenziato dagli altri poiché presenterà il multiplexer solo sull’ingresso destro, dato che il sinistro è legato all’input del registro.
    \item \textbf{UltimoFF:} è il primo flip flop da destra, ovvero quello di posizione N. È stato differenziato dagli altri poiché presenterà il multiplexer solo sull’ingresso sinistro, dato che il destro è legato all’input del registro.
    \item \textbf{FF\_with0:} sono i flipflop che, nel multiplexer per la selezione, presentano degli 0, in quanto non hanno abbastanza flipflop che li precedono. Es: nel flipflop di posizione 2, per l’ingresso sinistro, la scelta ricadrà tra l’uscita del flipflop di posizione 1 ed uno 0, dato che non esiste un flipflop di posizione 0.
    \item \textbf{FFintermedi:} sono quei flipflop che presentano multiplexer si per l’ingresso di destra che di sinistra, ed entrambi prendono gli ingressi da flipflop precedenti.
\end{itemize}
\clearpage
\begin{figure}[ht!]
    \centering
    \includesvg[width=\textwidth,height=0.9\textheight]{\Equattro esercizio4.svg}
    \caption{Progetto Completo}
\end{figure}
\subsection{Simulazione}
Verrà ora presentata una simulazione del funzionamento della macchina, verificando tutte le combinazioni dei segnali mode e shift. I risultati della simulazione sono analoghi per entrambe le architecture.
\begin{figure}[ht]
    \centering
    \includegraphics[width=1\textwidth,height=0.4\textheight]{\Equattro sim.png}
    \caption{Simulazione Shift Register}
\end{figure}
\newpage
\section{Esercizio 5 - Cronometro}
\newpage
\section{Esercizio 6 - Sistema di Testing}
\newpage
\section{Esercizio 7 - Comunicazione con Handshaking}
\newpage
\section{Esercizio 8 - Processor}
\newpage
\section{Esercizio 9 - Interfaccia UART}
\newpage
\section{Esercizio 10 - Switch Multistadio}
\newpage
\section{Esercizio 11 - Divisore Restoring}
\newpage
\section{Esercizio 12 - Interfaccia VGA}

\newpage
\listoffigures
\end{document}