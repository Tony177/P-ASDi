\documentclass[12pt]{article}

\usepackage{graphicx,caption,svg,enumitem}
\usepackage[utf8]{inputenc}

\renewcommand{\contentsname}{Indice}
\renewcommand{\labelenumii}{\arabic{enumi}.\arabic{enumii}}
\makeatletter
\renewcommand\paragraph{\@startsection{paragraph}{4}{\z@}%
            {-2.5ex\@plus -1ex \@minus -.25ex}%
            {1.25ex \@plus .25ex}%
            {\normalfont\large\bfseries}}
\renewcommand\subsubsection{\@startsection{subsubsection}{3}{\z@}%
            {-3.25ex\@plus -1ex \@minus -.2ex}%
            {1.5ex \@plus .2ex}%
            {\normalfont\large\bfseries}}
\makeatother
\setcounter{secnumdepth}{4} % how many sectioning levels to assign numbers to
\setcounter{tocdepth}{4}    % how many sectioning levels to show in ToC
\setlength{\parindent}{0pt}

\def \Euno {Allegati/Esercizio1/}
\def \Edue {Allegati/Esercizio2/}
\def \Etre {Allegati/Esercizio3/}
\def \Equattro {Allegati/Esercizio4/}
\def \Ecinque {Allegati/Esercizio5/}
\def \Esei {Allegati/Esercizio6/}
\def \Esette {Allegati/Esercizio7/}
\def \Eotto {Allegati/Esercizio8/}
\def \Enove {Allegati/Esercizio9/}
\def \Edieci {Allegati/Esercizio10/}
\def \Eundici{Allegati/Esercizio11/}
\def \Edodici {Allegati/Esercizio12/}


\begin{document}

\title{Tesina Architettura dei Sistemi Digitali}
\date{\today}
\tableofcontents
\newpage
\section{Esercizio 1 - Multiplexer}
\subsection{Parte 1}
L’esercizio 1.1 richiede la rappresentazione di un multiplexer 16:1 tramite la composizione di multiplexer 4:1, quindi definiamo il module del componente mux\_4\_1 definito in modo Dataflow, e poi per le proprietà della modularità definiamo il module mux\_16\_1 come composizione dei precedenti, tramite il costrutto \textit{for..generate}.


Il multiplexer 4:1 ha come ingressi quattro bit, identificati col vettore a(0 to 3), e $\lceil \log_{2}(n) \rceil$ segnali di abilitazione, dove n è il numero di segnali di ingresso. In questo caso, quindi, due segnali di abilitazione ed uno di uscita.
\begin{figure}[ht]
    \centering
    \includesvg[width=\textwidth,height=0.2\textheight]{\Euno mux_4_1.svg}
    \caption{Mux 4:1}
\end{figure}

Il codice in VHDL per descrivere il comportamento di questo componente è il seguente:
\begin{figure}[ht]
    \centering
    \includegraphics[width=\textwidth,height=0.3\textheight,keepaspectratio]{\Euno mux_4_1_dataflow.png}
    \caption{Mux 4:1 Dataflow}
\end{figure}

Composto da un costrutto \textit{when...else} che suddivide i diversi casi e gestisce anche tutti i casi non definiti con l’ultima clausola else senza alcuna condizione.

Definito l’elemento base del progetto, si passa a comporre il multiplexer 16:1 tramite un approccio strutturale, nel quale generiamo cinque mux\_4\_1: i primi quattro avranno gli ingressi interfacciati con l’esterno e, tramite segnali interni, le loro uscite sono collegate come ingressi dell’ultimo multiplexer che costituisce  l’uscita del sistema.
La macchina completa presenta quindi 16 segnali di ingresso, 4 segnali di selezione ed un unico segnale di uscita:

\begin{figure}[ht]
    \centering
    \includesvg[width=\textwidth,height=0.65\textheight]{\Euno mux_16_1.svg}
    \caption{Mux 16:1}
\end{figure}
\newpage
Lo schema sopra rappresentato è tradotto in linguaggio VHDL dal seguente codice, dove l’entità mux\_16\_1 è rappresentata con approccio strutturale e, tramite i segnali interni c(0 to 3), colleghiamo le uscite parziali dei primi quattro mux\_4\_1, identificati con la label mux\_4\_1\_in, con i quattro ingressi dell’ultimo mux\_4\_1, identificato con la label mux\_4\_1\_fin.
\begin{figure}[ht]
    \centering
    \includegraphics[width=1.3\textwidth,height=0.6\textheight,keepaspectratio]{\Euno mux_16_4_structural.png}
    \caption{Mux 16:1 Dataflow}
\end{figure}
\newpage
Progettato il mux\_16\_1, è possibile testarlo attraverso un testbench. La prima cosa che bisogna specificare è che il corpo dell’entity è vuoto, questo perché non si tratta di oggetto che realizziamo, ma serve solo per effettuare la simulazione e verificare se il sistema realizzato funziona correttamente. Il testbench effettivamente non ha né segnali d’ingresso né d’uscita, ma sfrutta per i test i segnali interni definiti nel codice. Per testare il mux\_16\_1 definito precedentemente, abbiamo istanziato una uut (Unit
Under Test) in cui colleghiamo le varie porte ai segnali (input, selection, output).\newline
\begin{figure}[h]
    \centering
    \includegraphics[width=1.2\textwidth,height=0.6\textheight,keepaspectratio]{\Euno mux_16_1_tb.png}
    \caption{Mux 16:1 Testbench}
\end{figure}
\newpage Dopo aver effettuato queste assegnazioni, compreso di costrutto after per permettere l’evoluzione del sistema durante il tempo, si passa alla schermata di simulazione nella quale si può analizzare e studiare l’evoluzione nel tempo di ogni segnale presente nel codice, compresi eventuali segnali intermedi.
\begin{figure}[ht]
    \centering
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Euno mux_16_1_simulazione.png}
    \caption{Mux 16:1 Simulazione}
\end{figure}
\newline Possiamo analizzare l’evoluzione del programma:
dopo circa 150ns, l’ingresso è posto a “0000000000000001” e contemporaneamente la selezione è posta a “1111”, ottenendo come uscita del sistema “1”. Questo è effettivamente il comportamento atteso.
\newpage


\subsection{Parte 2}
L’esercizio 1.2 è in parte riconducibile all’esercizio precedente, in quanto la rappresentazione di una rete 16:4 può essere scomposta da una sottorete 16:1 connessa ad un demux 1:4. Basta quindi aggiungere un demultiplexer 1:4 alla rete precedente. Il demux 1:4 è realizzato con approccio Dataflow.
\begin{figure}[ht]
    \centering
    \includegraphics[width=0.8\textwidth,height=\textheight,keepaspectratio]{\Euno demux_4_1_dataflow.png}
    \caption{Demux 1:4 Dataflow}
\end{figure}
\newline Il Demux 1:4 presenta come uscita un segnale di 4 bit, di cui 3 pari a zero ed uno pari al valore in ingresso, la cui posizione è determinata a seconda dei segnali di abilitazione.
\begin{figure}[ht]
    \centering
    \includesvg[width=\textwidth,height=0.4\textheight]{\Euno rete_16_4.svg}
    \caption{Rete 16:1}
\end{figure}
\newpage
Una volta eseguite le interconnessioni tramite un unico segnale interno, utilizzato per collegare l’uscita del mux\_16\_1 con l’ingresso del demux\_1\_4, si ottiene la rete 16:4:  tale rete presenta 16 segnali di ingressi totali, 6 di selezione (di cui 2 utilizzati per il demux) e 4 segnali di uscita.
\begin{figure}[ht]
    \centering
    \includegraphics[width=0.8\textwidth,height=\textheight,keepaspectratio]{\Euno rete_16_4_structural.png}
    \caption{Rete 16:4 Structural}
\end{figure}
\\
Anche dopo aver testato il singolo componente, è comunque necessario ripetere il test per la macchina completa, sia perché potrebbero essere presenti errori e problemi derivanti da implementazione di nuove funzioni, sia perché anche nella composizione di una macchina più complessa sono presenti intrinsecamente problemi legati alla coesione dei vari moduli.
\newpage
\begin{figure}[ht]
    \centering
    \includegraphics[width=0.4\textwidth,height=\textheight,keepaspectratio]{\Euno rete_16_4_tb.png}
    \caption{Rete 16:4 Testbench}
\end{figure}

\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.7\textwidth,height=\textheight,keepaspectratio]{\Euno rete_16_4_simulazione.png}
    \caption{Rete 16:4 Simulazione}
\end{figure}
\newpage

\subsection{Parte 3}
Come esercizio finale, è stato necessario adattare la rete per la sintesi sulla FPGA. Attraverso l’utilizzo di un file di constraint ideato per la board Nexys A7-50t, possiamo definire i collegamenti da effettuare sulla scheda tra le diverse periferiche disponibili e le componenti presenti all’interno della rete.
\newline
In questo caso sono necessari 6 switch per le linee di abilitazione dei multiplexer e demultiplexer. Poichè gli switch sono in totale 16, è stato necessario dare un input predefinito alla rete ed utilizzare gli switch unicamente per la selezione.
Inoltre, sempre dal file di costraint, sono stati abilitati anche 4 led e connessi ai quattro bit di uscita, come indicato nel seguente file.
\begin{figure}[ht]
    \centering
    \includegraphics[width=0.7\textwidth,height=\textheight,keepaspectratio]{\Euno costraints_es1.png}
    \caption{Costraints}
\end{figure}
\\Quindi, gli switch \textbf{\textit{J15-L16-M13-R15}} sono stati mappati ai quattro bit di selezione dei multiplexer, mentre gli switch \textbf{\textit{R17-T18}} ai due bit di selezione dei multiplexer, ed, infine, i led H17-K15-J13-N14 come rappresentazione visiva dei quattro bit di uscita al sistema complessivo.
\newline
Il sistema finale è quello raffigurato nella seguente figura
\begin{figure}[ht]
    \centering
    \includegraphics[width=0.8\textwidth,height=\textheight,keepaspectratio]{\Euno rete_16_4_analysis.png}
    \caption{Rete 16:4 Analysis}
\end{figure}


\newpage
\section{Esercizio 2 - Encoder BCD}
\subsection{Traccia}

Progettare, implementare in VHDL e testare mediante simulazione una rete che, data in ingresso una stringa binaria X di 10 bit X9 X8 X7 X6 X5 X4 X3 X2 X1 X0 che corrisponde alla rappresentazione decodificata di una cifra decimale (cioè, una rappresentazione in cui ogni stringa contiene un solo bit alto), fornisce in uscita la rappresentazione Y della cifra mediante codifica Binary-Coded Decimali (BCD).
\\Input: 0000000001 $\Rightarrow$ Output: 0000 (cifra 0)
\\Input: 0000000010 $\Rightarrow$ Output: 0001 (cifra 1)
\\Input: 0000000100 $\Rightarrow$ Output: 0010 (cifra 2)
\\....
\\Sintetizzare ed implementare su board il progetto dell’encoder BCD utilizzando gli switch per fornire la stringa X in ingresso, e i led per visualizzare Y. Nel caso in cui si utilizzi una board dotata di soli 8 switch, è possibile sviluppare il progetto considerando X di soli 8 bit (la macchina sarà allora in grado di fornire in uscita la rappresentazione BCD delle cifre decimali da 0 a 7).
\\Utilizzare un display a 7 segmenti per visualizzare la cifra decimale codificata da Y (pilotare opportunamente i catodi del display per visualizzare la cifra).
\subsection{Soluzione}
La rete è stata realizzata con vari componenti secondo un approccio strutturale. Essa ha un ingresso, cioè il valore della stringa X da 10 bit, e 2 uscite, utili per visualizzare la cifra codificata su un display a 7 segmenti.
La rete utilizza i seguenti componenti:
\begin{itemize}
    \item Un encoder: a sua volta composto da un arbitro a priorità e da un encoder 10:4;
    \item Un display manager per la visualizzazione dell’output;
\end{itemize}
Si è partiti, dunque, da una descrizione dataflow dei componenti base, per poi procedere con una descrizione strutturale dell’encoder ed una descrizione comportamentale del display manager. Infine, mettendo insieme questi ultimi 2 componenti, si è descritto l’intero sistema, chiaramente a livello strutturale.

    {\large  \textbf{Arbitro a priorità:}}
\\Il componente relativo all’arbitro di priorità dispone di un vettore di ingresso di 10 bit e di un vettore di uscita di altrettanti bit, in cui l’uscita avrà tutti 0 e un solo bit alto nella prima posizione in cui è stato trovato un 1 (a partire dalla posizione più significativa).
\\\\{\large \textbf{Encoder 10:4:}}
\\Il componente relativo all’encoder 10:4 presenta in ingresso un vettore di 10 bit ed in uscita un vettore di 4 bit, che rappresenta il numero in binario della prima posizione con bit alto in ingresso (valore compreso nel range [0,9]).
\\\\Facendo uso dei due componenti appena descritti, si è realizzato un encoder, il quale facendo uso di un segnale interno che fa da interconnessione tra l’uscita dell’arbitro e l’ingresso dell’encoder 10:4, prende in ingresso un vettore di 10 bit e restituisce in uscita un vettore di 4 bit effettuando la codifica Binary-Coded Decimal (BCD).
\\\\{\large \textbf{Display Manager:}}
\\Il componente display manager prende in ingresso un vettore di 4 bit e lo rappresenta sul display a 7 segmenti con 2 uscite. Al suo interno vengono definite delle costanti su 7 bit relative ai segmenti di una cifra del display da illuminare, in questo modo si visualizza un determinato valore in esadecimale. La prima uscita è fissa, al fine di illuminare costantemente solo la prima cifra del display, poiché il valore da mostrare è rappresentabile con una sola cifra. La seconda uscita determina i segmenti della cifra da illuminare, pertanto dipende dall’ingresso.
\\La rete complessiva dispone dell’encoder e del display manager. Il vettore di ingresso di 10 bit andrà nell’encoder e la sua uscita su 4 bit, mediante un segnale di interconnessione, andrà in ingresso al display manager che mostra il valore di uscita sul display.
\newpage
\subsection{Codice}
{\large \textbf{Arbitro}}
\\L’architettura è stata descritta a livello dataflow e, scorrendo un vettore a partire dalla posizione 9 fino a 0, se tra i 10 bit uno solo è alto, l’uscità sarà una stringa con tutti 0 e solo un bit alto nella posizione in cui lo era nel vettore di ingresso. Nel caso in cui il vettore di ingresso presenta più bit uguali a 1, la stringa in uscita avrà il solo bit alto nella prima posizione, partendo dalla 9, in cui trova un 1.
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.7\textwidth,height=\textheight,keepaspectratio]{\Edue codice_arbitro.jpg}
    \caption{Codice Arbitro}
\end{figure}
\newpage
{\large \textbf{Encoder 10:4}}

L’encoder 10:4 è stato descritto a livello dataflow. L’architettura, partendo da un vettore con solo un bit alto, restituisce in uscita il valore su 4 bit della posizione in cui il bit è alto.
\begin{figure}[ht]
    \centering
    \includegraphics[width=0.6\textwidth,height=\textheight,keepaspectratio]{\Edue codice_encoder10_4.jpg}
    \caption{Codice Encoder 10:4}
\end{figure}
\newpage
{\large \textbf{Encoder complessivo}}
\\L’encoder complessivo è descritto a livello strutturale utilizzando i componenti “arbitro” e “encoder10\_4”. All’interno del sistema è definito un segnale t di tipo std\_logic\_vector(9 downto 0), che fa da interconnessione e viene utilizzato come uscita dell’arbitro e come ingresso dell’encoder 10:4.
\begin{figure}[ht]
    \centering
    \includegraphics[width=0.6\textwidth,height=\textheight,keepaspectratio]{\Edue codice_encoder_parte1.jpg}
\end{figure}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.5\textwidth,height=\textheight,keepaspectratio]{\Edue codice_encoder_parte2.jpg}
    \caption{Codice Encoder Complessivo}
\end{figure}
\newpage
{\large \textbf{Display Manager}}
\begin{figure}[ht]
    \centering
    \includegraphics[width=0.2\textwidth,height=\textheight,keepaspectratio]{\Edue display.jpg}
    \caption{Display Segment}
\end{figure}
\newline
Questo componente viene descritto a livello comportamentale. Viene definita l’entity con una porta in ingresso, value, e due porte in uscita, anode e cathode, tutte di tipo std\_logic\_vector. Nel costrutto architecture sono definite delle costanti di 7 bit, dove la posizione rappresenta un segmento di una cifra del display: quando il bit è 0 il segmento è acceso, altrimenti è spento. Poiché il valore è in notazione esadecimale, sono state definite le costanti che rappresentano i valori da 0 a f. Per tenere accesa solo la prima cifra del display, l’uscita anode viene settata con tutti i bit alti, ad eccezione di quello meno significativo; in questo modo le cifre successive alla prima sono spente. Si usa l’altra uscita, cathode, per rappresentare il valore tramite una AND tra ‘1’ e la costante che rappresenta il valore da mostrare a video.
\begin{figure}[ht]
    \centering
    \includegraphics[width=0.9\textwidth,height=\textheight,keepaspectratio]{\Edue codice_display_manager_parte1.jpg}
\end{figure}
\begin{figure}[ht]
    \centering
    \includegraphics[width=0.8\textwidth,height=\textheight,keepaspectratio]{\Edue codice_display_manager_parte2.jpg}
\end{figure}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.9\textwidth,height=\textheight,keepaspectratio]{\Edue codice_display_manager_parte3.jpg}
    \caption{Codice Display Manager}
\end{figure}
\newpage
{\large \textbf{Sistema Completo}}
\\Nella descrizione strutturale dell’architettura si definiscono i componenti encoder, quello complessivo, e display manager e si definisce un segnale interno temp, di tipo std\_logic\_vector, che fa da interconnessione tra l’uscita dell’encoder e l’ingresso del display manager, al fine di rappresentare a video l’output dell’encoder.
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.5\textwidth,height=\textheight,keepaspectratio]{\Edue codice_sistema_completo_parte1.jpg}
\end{figure}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.5\textwidth,height=\textheight,keepaspectratio]{\Edue codice_sistema_completo_parte2.jpg}
\end{figure}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.4\textwidth,height=\textheight,keepaspectratio]{\Edue codice_sistema_completo_parte3.jpg}
    \caption{Codice Sistema Completo}
\end{figure}
\subsection{Simulazione}
Per effettuare la simulazione è stato utilizzato il seguente testbench per l’encoder:
\begin{figure}[ht]
    \centering
    \includegraphics[width=0.6\textwidth,height=\textheight,keepaspectratio]{\Edue sim1.jpg}
\end{figure}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.6\textwidth,height=\textheight,keepaspectratio]{\Edue sim2.jpg}
    \caption{Codice Testbench}
\end{figure}
\begin{figure}[ht]
    \centering
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Edue simulazione_encoder.jpg}
    \caption{Simulazione Encoder}
\end{figure}
\clearpage
\section{Esercizio 3 - Riconoscitore di Sequenze}
\subsection{Traccia}
Progettare, implementare in VHDL e testare mediante simulazione una macchina in grado di riconoscere la sequenza 1001. La macchina prende in ingresso un segnale binario i che rappresenta il dato, un segnale A di tempificazione e un segnale M di modo, che ne disciplina il funzionamento, e fornisce un’uscita Y alta quando la sequenza viene riconosciuta. In particolare,
\begin{itemize}
    \item se M=0, la macchina valuta i bit seriali in ingresso a gruppi di 4,
    \item se M=1, la macchina valuta i bit seriali in ingresso uno alla volta, tornando allo stato iniziale ogni volta che la sequenza viene correttamente riconosciuta.
\end{itemize}
Sintetizzare e implementare su board la rete sviluppata al punto precedente, utilizzando uno switch S1 per codificare l’input i e uno switch S2 per codificare il modo M, in combinazione con due bottoni B1 e B2 utilizzati rispettivamente per acquisire l’input da S1 e S2 in sincronismo con il segnale di tempificazione A, che deve essere ottenuto a partire dal clock della board. Infine, l’uscita Y può essere codificata utilizzando un led.
\subsection{Soluzione}

La macchina realizzata è un riconoscitore che, in base al modo stabilito, riconosce la sequenza 1001. Pertanto, il riconoscitore viene descritto a livello strutturale e dispone di 3 componenti:
\begin{itemize}
    \item Il debouncer (descritto a livello comportamentale);
    \item Un gestore per il modo (descritto a livello strutturale);
    \item Il sistema che si occupa del riconoscimento vero e proprio (descritto a livello comportamentale).
\end{itemize}
\newpage
{\large \textbf{Sistema per il riconoscimento}}

Il sistema che effettua il riconoscimento viene descritto a livello comportamentale.
\begin{figure}[ht]
    \centering
    \includegraphics[width=0.7\textwidth,height=\textheight,keepaspectratio]{\Etre codice_sistema_parte1.png}
    \caption{Codice Sistema Pt1}
\end{figure}
\\Nella descrizione è definito un tipo enumerativo “status” che contiene tutti i possibili stati della macchina: S0, S1, S2, S3, S4, S5, S6, S7. Per quanto riguarda il modo, nello specifico, se M=1 vengono considerati i primi 5 stati, se M=0 vengono considerati tutti.
Tra questi, lo stato S4 viene raggiunto se la sequenza 1001 è stata riconosciuta.
Il comportamento della macchina è definito da un process sensibile al clock:
Se il segnale di RESET è alto, allora resetta lo stato corrente della macchina, riportandolo a S0, e permette di acquisire il nuovo modo M.
Se M=1,
\begin{itemize}
    \item Stato S0: se si riceve in ingresso 0, si permane in S0; se si riceve 1, si va in S1, poiché è stato riconosciuto un 1 (prima cifra della sequenza cercata);
    \item Stato S1: se si riceve 1, si permane in S1, poiché non è la prossima cifra cercata, ma l’ultima trovata è un 1; se si riceve 0, si va in S2 ed è stata riconosciuta la sequenza 10;
    \item Stato S2: se si riceve 1, si ritorna in S1; se si riceve 0, si va in S3 ed è stata riconosciuta 100;
    \item Stato S3: se si riceve 0, si ritorna in S0, poiché sarebbe stata riconosciuta la sequenza 1000, che non è quella che si ricercava; se si riceve 1, si va in S4 e si riconosce proprio la sequenza 1001.
\end{itemize}
Se M=0, c’è un concetto di conteggio su 4 bit, pertanto anche in caso di valore non ricercato in ingresso, si procede in avanti verso altri stati. Nello specifico,
\begin{itemize}
    \item Stato S0: se si riceve 1, come prima si va in S1; altrimenti si va in S5;
    \item Stato S1: se si riceve 0, si va in S2; altrimenti si va in S6;
    \item Stato S2: se si riceve 0, si va in S3; altrimenti in S7;
    \item Stato S3: se si riceve 1, si va in S4 e la sequenza 1001 è stata riconosciuta; altrimenti si torna in S0 perché su 4 bit è stata riconosciuta la sequenza 1000, che non è quella cercata.
\end{itemize}
Per gli stati successivi non importa il bit ricevuto in ingresso, in quanto a gruppi di 4 bit alla volta non sarebbe riconosciuta la sequenza ricercata, pertanto
\begin{itemize}
    \item Stato S5: va in S6;
    \item Stato S6: va in S7;
    \item Stato S7: va in S0.
\end{itemize}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=\textwidth,height=0.4\textheight,keepaspectratio]{\Etre codice_sistema_parte2.png}
\end{figure}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=\textwidth,height=0.55\textheight,keepaspectratio]{\Etre codice_sistema_parte3.png}
\end{figure}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=\textwidth,height=0.3\textheight,keepaspectratio]{\Etre codice_sistema_parte4.png}
    \caption{Codice Sistema Pt2}
\end{figure}
\clearpage
{\large \textbf{Debouncer}}
\\Tale componente ha il compito di trasformare un segnale rumoroso in un segnale pulito. Quando un segnale arriva da un bottone sarà sicuramente effetto da rumore, come riportato in figura. Ad un occhio umano, tali oscillazioni non vengono percepite ma, quando tale segnale viene analizzato ad un microcontrollore, queste vengono rilevate a pieno e potrebbero creare problemi (se tale segnale va in ingresso ad un contatore si traduce in conteggi spuri).
\begin{figure}[ht!]
    \centering
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Etre debouncer.png}
    \caption{Debouncer}
\end{figure}
Il debouncer viene progettato come una macchina a stati:
\begin{itemize}
    \item Stato not pressed: il sistema permane in questo stato finchè non vede il segnale in ingresso alzarsi. Passa così nello stato pressed.
    \item Stato pressed: il sistema permane in questo stato finchè il segnale in ingresso non si abbassa. Quando ciò accade, si utilizza una variabile di conteggio, la quale fa si che passi un periodo di tempo pari a D2 prima di riportare il segnale come alto in uscita e tornare nello stato not pressed.
\end{itemize}
Il segnale in uscita rimane alto per un periodo di clock dato che, quando il sistema ritorna nello stato not pressed, l’uscita viene abbassata nuovamente. A differenza di un debouncer classico, l’uscita viene riportata alta solo dopo che il segnale si è abbassato e non dopo un tempo D1 dal fronte di salita; la scelta è stata fatta poiché, altrimenti, se il bottone venisse premuto troppo a lungo potrebbe essere rilevato nuovamente ed in uscita si produrrebbero 2 segnali puliti invece di 1.
\newpage
{\large \textbf{Filtro per il modo}}

Questo componente prende in ingresso il segnale filtrato dal debouncer, chiamato “cleared\_button”, il clock e l’input dallo switch S2, che rappresenta il modo, e restituisce il modo. Viene descritto a livello comportamentale:  se il bottone B2 è premuto, il modo viene impostato tramite S2.
\begin{figure}[ht]
    \centering
    \includegraphics[width=0.6\textwidth,height=\textheight,keepaspectratio]{\Etre codice_filtro_modo.jpg}
    \caption{Codice filtro modo}
\end{figure}
\\{\large \textbf{Gestore per il modo}}
\\Il componente relativo alla gestione del modo viene descritto a livello strutturale e si compone di un debouncer e di un filtro per il modo. Prende in ingresso il clock, il segnale del bottone B2, l’input dallo switch S2. B2 va in ingresso al debouncer per la pulizia del segnale e l’uscita del debouncer, attraverso il segnale interno cb\_temp va in ingresso al filtro insieme a S2. L’uscita sarà data dal filtro, pertanto sarà il modo, che successivamente sarà dato in ingresso al sistema di riconoscimento.
\begin{figure}[ht]
    \includegraphics[width=0.5\textwidth,height=\textheight,keepaspectratio]{\Etre codice_gestore_modo_parte1.jpg}
\end{figure}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=1.1\textwidth,height=0.7\textheight]{\Etre codice_gestore_modo_parte2.jpg}
    \caption{Codice gestore modo}
\end{figure}
\clearpage
{\large \textbf {Riconoscitore}}
\\Il riconoscitore complessivo viene descritto in modo Strutturale tramite i componenti presentati finora.
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.8\textwidth,height=\textheight,keepaspectratio]{\Etre codice_riconoscitore_parte1.jpg}
\end{figure}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.8\textwidth,height=\textheight,keepaspectratio]{\Etre codice_riconoscitore_parte2.jpg}
\end{figure}
\clearpage
\begin{figure}[ht!]
    \centering
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Etre codice_riconoscitore_parte3.jpg}
    \caption{Codice riconoscitore}
\end{figure}
{\large \textbf{Simulazione}}
\\Per la simulazione si è usato il seguente testbench sul riconoscitore completo, compreso di sistema di riconoscimento, debouncer e gestore del modo:
\begin{figure}[ht!]
    \centering
    \includegraphics[width=\textwidth,height=0.15\textheight]{\Etre simulazione_riconoscitore.jpg}
    \caption{Simulazione riconoscitore}
\end{figure}
\newpage
\section{Esercizio 4 - Shift Register}
\subsection{Traccia}
{\large \textbf{Shift register}}
\\L’esercizio richiede la progettazione di uno shift register, mediante un approccio sia comportamentale che strutturale, con le seguenti caratteristiche:
\begin{itemize}
    \item Modo variabile: lo shift register, sulla base di un segnale in ingresso, deve effettuare shift verso destra o verso sinistra.
    \item Shift variabile: sulla base di un segnale in ingresso, il registro deve poter variare il numero di posizioni di shift.
\end{itemize}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Equattro entity_shift.png}
    \caption{Entity Shift Bidirezionale}
\end{figure}
\subsection{Approccio comportamentale}
Per la progettazione di tipo comportamentale è stato utilizzato il costrutto \textit{if}, dato che sia le opzioni di modo che di shift comprendevano solo due possibilità; in un caso più generale, il costrutto case sarebbe più appropriato.
Lo shift register realizzato prevede un ingresso seriale ed un output parallelo, gestiti nel seguente modo:
\begin{itemize}
    \item Ingresso mode: tale segnale varia la modalità di shift: se pari ad 1, il valore viene inserito da destra, altrimenti da sinistra.
    \item Ingresso a: tale segnale funge da abilitazione, ovvero il registro effettua uno shift solo se, sul fronte di salita del clock, rileva un’abilitazione pari ad 1.
    \item Ingresso shift: è il segnale che gestisce il numero di posizioni dello shift: quando è pari a 0, avviene lo shift di una posizione, altrimenti di due.
\end{itemize}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.8\textwidth,height=0.8\textheight,keepaspectratio]{\Equattro architecture_shift.png}

\end{figure}

\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.3\textwidth,height=0.3\textheight,keepaspectratio]{\Equattro architecture_shift_2.png}
    \caption{Architecture Shift Register Bidirezionale}
\end{figure}
\clearpage
\subsection{Approccio Strutturale}
Per la realizzazione tramite un approccio strutturale, sono stati realizzati dei flip flop D bidirezionali.
\\\\{\large \textbf{Component Ffd\_bidirezionali:}}
\begin{figure}[ht]
    \centering
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Equattro ffd1.png}
    \caption{Entity Flip Flop D}
\end{figure}
\\La logica di tale componente è molto semplice:
\\prevede 2 ingressi (leftInput e RightInput) e, in base al segnale di mode in ingresso, decide quale riportare in uscita. Tale componente è sincrono e lavora solo con abilitazione pari ad 1.
\clearpage
\begin{figure}[ht]
    \centering
    \includegraphics[width=\textwidth,height=0.7\textheight,keepaspectratio]{\Equattro ffd2.png}
    \caption{Architecture Flip Flop D}
\end{figure}
{\large \textbf{Component mux\_2\_1:}}
\\Tale componente è necessario per selezionare quale valore deve essere riportato in ingresso ai flipflop, in base allo shift richiesto.
Dato che lo shift può variare al massimo di una posizione, un multiplexer 2:1 è sufficiente; in un caso più generale, si potrebbe ricorrere ad un multiplexer con un numero maggiore di ingressi.
\clearpage
\begin{figure}[ht]
    \centering
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Equattro mux.png}
    \caption{Mux 2:1}
\end{figure}
Vediamo ora come tali componenti sono stati combinati:
\clearpage
\begin{figure}[ht!]
    \centering
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Equattro generate1.png}
\end{figure}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Equattro generate2.png}
    \caption{ Generate FFD}
\end{figure}
\begin{itemize}
    \item \textbf{PrimoFF:} è il primo flip flop da sinistra, ovvero quello di posizione 1. È stato differenziato dagli altri poiché presenterà il multiplexer solo sull’ingresso destro, dato che il sinistro è legato all’input del registro.
    \item \textbf{UltimoFF:} è il primo flip flop da destra, ovvero quello di posizione N. È stato differenziato dagli altri poiché presenterà il multiplexer solo sull’ingresso sinistro, dato che il destro è legato all’input del registro.
    \item \textbf{FF\_with0:} sono i flipflop che, nel multiplexer per la selezione, presentano degli 0, in quanto non hanno abbastanza flipflop che li precedono. Es: nel flipflop di posizione 2, per l’ingresso sinistro, la scelta ricadrà tra l’uscita del flipflop di posizione 1 ed uno 0, dato che non esiste un flipflop di posizione 0.
    \item \textbf{FFintermedi:} sono quei flipflop che presentano multiplexer si per l’ingresso di destra che di sinistra, ed entrambi prendono gli ingressi da flipflop precedenti.
\end{itemize}
\clearpage
\begin{figure}[ht!]
    \centering
    \includesvg[width=\textwidth,height=0.9\textheight]{\Equattro esercizio4.svg}
    \caption{Progetto Completo Esercizio 1}
\end{figure}
\subsection{Simulazione}
Verrà ora presentata una simulazione del funzionamento della macchina, verificando tutte le combinazioni dei segnali mode e shift. I risultati della simulazione sono analoghi per entrambe le architecture.
\begin{figure}[ht]
    \centering
    \includegraphics[width=1\textwidth,height=0.4\textheight]{\Equattro sim.png}
    \caption{Simulazione Shift Register}
\end{figure}
\newpage
\section{Esercizio 5 - Cronometro}
\subsection{Traccia}
{\large \textbf{Cronometro}}
\\L’obiettivo di questo esercizio è quello di progettare un cronometro tramite un approccio strutturale, visualizzando i valori di ore, minuti e secondi sul display presente sulla board.
Il progetto prevede sicuramente l’utilizzo di una serie di contatori, i quali dovranno scandire il tempo.
\\{\large \textbf{Contatore:}}
\begin{figure}[ht]
    \centering
    \includegraphics[width=\textwidth,height=0.2\textheight]{\Ecinque entity_contatore.png}
    \caption{Entity Contatore}
\end{figure}
\\Tale contatore è stato implementato tramite un approccio comportamentale, in modo da incrementare il valore di conteggio solo in presenza di un opportuno segnale di abilitazione.
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.6\textwidth,height=0.3\textheight,keepaspectratio]{\Ecinque architecture_contatore.png}
    \caption{Architecture Contatore}
\end{figure}
\\Data la richiesta di poter settare i valori di secondi, minuti e ore da cui il cronometro deve partire, si è deciso di introdurre due ingressi aggiuntivi: un segnale di set ed un vettore d’ingresso.
Sostanzialmente, quando il segnale di set è alto, il contatore non rileva il segnale di abilitazione e carica il valore presente in ingresso; quando il segnale di set si abbassa, il contatore ritorna al suo normale funzionamento.
Una volta definiti tre contatori differenti per scandire ore, minuti e secondi, vediamo come questi sono stati combinati tra loro.
\\\\{\large \textbf{Sistema Contatori:}}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Ecinque entity_sistema_c.png}
    \caption{Entity Sistema Contatori}
\end{figure}
\\E’ formato da 4 contatori, 1 blocco di delay ed un blocco AND. Il primo contatore che ritroviamo è un divisore di frequenza, il quale ha il compito di passare dalla frequenza del clock della board a quella di 1HZ, la cui uscita di div funge da abilitazione per  il contatore dei secondi.
L’uscita di div del contatore  dei secondi entra, poi, come abilitazione del contatore relativo ai minuti; entrambi i contatori sono definiti modulo 60.
Leggermente più complessa è la connessione con il contatore relativo alle ore, il quale dovrà effettuare un conteggio quando sia il contatore dei secondi che quello dei minuti sono arrivati al termine. Come segnale di abilitazione, dunque, si utilizza l’uscita di una porta and, che presenta come ingresso entrambi i segnali di div dei contatori precedenti.
Si presenta però un problema di tempificazione: il segnale di div del contatore relativo ai secondi, fungendo da abilitazione al contatore dei minuti e rimanendo alto per 1 solo colpo di clock, si alzerebbe appunto un colpo di clock prima di quello dei minuti; si è realizzato pertanto un blocco di delay, il quale ritarda tale segnale di 1 colpo di clock, in modo che la porta AND possa vedere entrambi i segnali alti. Se non avessimo usato tale blocco, il contatore delle ore non avrebbe mai visto il segnale di abilitazione alto.
\begin{figure}[ht]
    \centering
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Ecinque architecture_sistema_c.png}
\end{figure}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=\textwidth,height=0.4\textheight]{\Ecinque struct.png}
    \caption{Struct Sistema Contatori}
\end{figure}
\clearpage
{\large \textbf{Component wait\_block:}}
\\E' stato progettato mediante un approccio comportamentale, con lo scopo di ritardare di 1 colpo di clock il segnale in ingresso.
\begin{figure}[ht!]
    \centering
    \includegraphics[width=\textwidth,height=0.4\textheight,keepaspectratio]{\Ecinque wait_block.png}
    \caption{Wait Block}
\end{figure}
\\{\large \textbf{Schema sistema contatori}}
\begin{figure}[ht!]
    \centering
    \includesvg[width=\textwidth,height=\textheight]{\Ecinque sistema_contatori.svg}
\end{figure}
\\Definita la parte relativa al conteggio, possiamo ora vedere i componenti necessari al set di un valore iniziale dei contatori, in modo da far partire il cronometro da un orario scelto.
\\\\{\large \textbf{Component gestore\_set:}}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=\textwidth,height=0.4\textheight,keepaspectratio]{\Ecinque gestore_set.png}
    \caption{Gestore set}
\end{figure}
\\Il segnale di set in ingresso ai contatori viene processato da un gestore di set, il quale ha il compito di mantenere quel segnale sempre alto finché non vengono settate ore, minuti e secondi.
Il segnale di set viene prodotto dal gestore\_set in base ad un segnale fornito dall’esterno tramite un pulsante: la prima volta che si riceve tale segnale, il valore di set viene posto ad 1.
A questo punto, tutti i contatori fermano il conteggio e rimangono in attesa di un vettore in ingresso e, tramite una variabile di conteggio chiamata count, si gestisce quale contatore inizializzare ad ogni passo.
Il vettore in ingresso, infatti, contiene solo 6 bit e viene ogni volta aggiornato con il valore di ore, minuti e secondi che si vuole caricare; si è preferita una scelta di questo tipo rispetto ad un unico vettore contenente 17 ingressi dato che, quando si passerà alla sintesi su fpga, non saranno presenti 17 switch per gli input.
Tornando alla variabile count, vediamo come il componente gestisce gli ingressi:
\begin{itemize}
    \item Count=1 : i valori in ingresso vengono caricati nel counter dei secondi;
    \item Count=2 : i valori in ingresso vengono caricati nel counter dei minuti;
    \item Count=3 : i valori in ingresso vengono caricati nel counter delle ore;
\end{itemize}
Quando il count arriva a 3, inoltre, il suo valore viene portato a 0, indicando la fine dei dati in input da ricevere.
Il valore di count viene incrementato ogni volta che arriva il segnale esterno che definisce il set; la quarta volta che il gestore riceve tale segnale, il valore di count sarà pari a 0 e, dunque, il segnale di set in uscita verrà abbassato e il cronometro riprende il suo normale funzionamento.
È bene notare che, tutte le operazioni del gestore\_set vengono eseguite quando il segnale di ingresso ab\_modo è pari a 0; il motivo verrà spiegato nel seguito.
\begin{figure}[ht!]
    \centering
    \includegraphics[width=\textwidth,height=0.3\textheight,keepaspectratio]{\Ecinque set1.png}
\end{figure}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=\textwidth,height=0.3\textheight,keepaspectratio]{\Ecinque set2.png}
    \caption{Architecture Gestore set}
\end{figure}
\clearpage
L’implementazione riportata è già adattata alla sintesi su fpga, introducendo dei valori di output relativi all’accensione di alcuni led, i quali indicano quale counter stiamo inizializzando.

\subsection{Sintesi su fpga}
Così come richiesto nell’esercizio 5.2, il componente cronometro realizzato in precedenza verrà sintetizzato su fpga. In particolare, verrà utilizzato il display a 7 segmenti presente sulla board, per la visualizzazione dell’orario, e 2 bottoni, per inviare i segnali di set e reset.
Tuttavia, tale sintesi non può essere immediata, ma  necessita di 2 componenti aggiuntivi:
\begin{itemize}
    \item Debouncer: componente che serve a ripulire il segnale inviato dal bottone, che sarà sicuramente caratterizzato da rumore.
    \item Convertitore per display: l’uscita dei contatori deve essere tradotta in un formato leggibile dal display.
\end{itemize}
{\large \textbf{Componente debouncer:}}
\\Tale componente ha il compito di trasformare un segnale rumoroso in un segnale pulito e la sua implementazione è analoga a quella riportata nell’esercizio 3.
\\\\\\{\large \textbf{Componente conv\_per\_display:}}
\\Tale componente è stato progettato con un approccio dataflow: prende in ingresso i vettori in uscita dai contatori e traduce ognuno di essi in 2 vettori da 4 bit (richiesti dal display in ingresso), i quali rappresentano i valori di decine e unità.
\clearpage
\begin{figure}[ht]
    \centering
    \includegraphics[width=\textwidth,height=0.6\textheight,keepaspectratio]{\Ecinque conv.png}
    \caption{Convertitore per display}
\end{figure}
Le uscite di questo componente andranno poi in ingresso al display\_manager.
\newline\newline\textbf{Estensione con intertempi:}
\\Per far si che il sistema sia in grado di memorizzare degli intertempi, sono stati aggiunti ulteriori componenti:
\begin{itemize}
    \item Gestore modo: necessario per la visualizzazione degli intertempi salvati.
    \item Memoria: componente nel quale salvare gli intertempi.
\end{itemize}
{\large \textbf{Componente Gestore\_modo:}}
\begin{figure}[ht]
    \centering
    \includegraphics[width=\textwidth,height=0.3\textheight,keepaspectratio]{\Ecinque modo1.png}
    \caption{Entity Gestore modo}
\end{figure}
\clearpage
E' stato realizzato come una macchina a 2 stati
\begin{itemize}
    \item Stato cronometro: a tale stato è associata l’uscita ab\_modo=0, la quale indica che l’uscita sul display è quella del sistema dei contatori, ovvero stiamo visualizzando il cronometro che scorre. Quando riceve in ingresso il segnale di cambio modo, inviato da un pulsante e gestito da un debouncer, si passa allo stato intertempo.
    \item Stato intertempo: a tale stato è associata l’uscita ab\_modo=1, la quale indica dunque che l’uscita sul display è quella della memoria, ovvero stiamo visualizzando gli intertempi salvati.
\end{itemize}
Per implementare la modalità intertempi, dunque, le uscite dei contatori e della memoria entrano nel gestore modo il quale, in base alla modalità di funzionamento del sistema, decide quale dei due ingressi riportare in uscita. Tale uscita andrà poi in ingresso al convertitore per display.
L’uscita ab\_modo verrà inoltre riportata in ingresso alla memoria ed al gestore set, in quanto ne limita le funzionalità:
\begin{itemize}
    \item Gestore set: quando siamo nella modalità intertempo, non è possibile settare un valore nei contatori.
    \item Memoria: quando si è nella modalità cronometro e si invia un segnale di write, allora l’intertempo viene scritto in memoria, altrimenti no. Inoltre, i dati possono essere letti dalla memoria e riportati sullo schermo, in corrispondenza di un segnale di read, solo quando il sistema è in modalità intertempo.
\end{itemize}
È bene notare che il segnale di ab\_modo non va in ingresso al sistema di contatori. Si è infatti supposto che, anche quando si è in modalità intertempo, il cronometro continua a lavorare, ma il tempo non viene mostrato sul display. Quando si ripassa alla modalità cronometro, infatti, si noterà che il valore di conteggio sarà avanzato.
\begin{figure}[ht!]
    \includegraphics[width=\textwidth,height=0.7\textheight,keepaspectratio]{\Ecinque modo2.png}
\end{figure}
\begin{figure}[ht!]
    \includegraphics[width=\textwidth,height=0.1\textheight,keepaspectratio]{\Ecinque modo3.png}
    \caption{Architecture Gestore modo}
\end{figure}
\clearpage
{\large \textbf{Componente memoria:}}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=\textwidth,height=0.5\textheight,keepaspectratio]{\Ecinque memoria.png}
    \caption{Entity Memoria}
\end{figure}
\\Tale componente è stato progettato tramite un approccio comportamentale e varia le sua funzionalità in base alla modalità di lavoro del sistema:
\begin{itemize}
    \item Modalità intertempo: permette, in corrispondenza di un segnale di read, di scorrere gli intertempi salvati. Non si possono salvare nuovi intertempi in tale modalità.
    \item Modalità cronometro: permette, in corrispondenza di un segnale di write, di salvare l’intertempo in memoria. Non si possono visualizzare gli intertempi salvati in tale modalità.
\end{itemize}
Per come è stata progettata, se si salvano più di N intertempi, vengono sovrascritti i primi che sono stati salvati.
\begin{figure}[ht!]
    \centering
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Ecinque memoriab.png}
    \caption{Architecture Memoria}
\end{figure}
\begin{figure}[ht!]
    \centering
    \includesvg[width=\textwidth,height=\textheight]{\Ecinque esercizio5.svg}
    \caption{Schema Completo Esercizio 5}
\end{figure}
\clearpage
\section{Esercizio 6 - Sistema di Testing}
\subsection{Traccia}
\textbf{Esercizio 6.1:} Progettare, implementare in VHDL e verificare mediante simulazione un sistema in grado di testare in maniera automatica una macchina combinatoria M avente 4 ingressi e 3 uscite binarie sottoponendole N ingressi diversi (si considerino una macchina M e un numero di input N a scelta dello studente).
Gli N valori di input per il test devono essere letti da una ROM, in cui essi sono precaricati, in corrispondenza di un segnale read. Le N uscite fornite della macchina in corrispondenza di ciascuno degli input devono essere memorizzati in una memoria interna, che deve poter essere svuotata in qualsiasi momento in presenza di un segnale di reset.
\\\\\textbf{Esercizio 6.2:} Sintetizzare ed implementare su board il componente sviluppato al punto precedente, utilizzando due bottoni per i segnali di read e reset rispettivamente e i led per la visualizzazione delle uscite della macchina istante per istante.
\subsection{Implementazione}
{\large \textbf{Scelte progettuali:}}
\\L’esercizio richiedeva di progettare un sistema di testing per una macchina combinatoria, a partire da dei valori di input per la macchina precaricati in una ROM, si visualizza l’output della macchina combinatoria a tali valori tramite dei LED. Gli output vengono visualizzati a intervalli di 1s. Per poter iniziare il testing della macchina occorre un segnale di RESET, necessario per svuotare la memoria, ed un segnale di READ, per presentare in ingresso alla macchina gli input presenti nella ROM.
\begin{figure}[ht!]
    \centering
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Esei sistema_esterno.jpg}
\end{figure}
\clearpage
Il sistema è stato progettato mediante un approccio strutturale:
\begin{figure}[ht!]
    \centering
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Esei sistema_comp.jpg}
    \caption{Sistema Complessivo}
\end{figure}
\\\\{\large \textbf{Tester:}}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Esei tester.jpg}
    \caption{Tester}
\end{figure}
\clearpage
Il tester è anch’esso realizzato con approccio strutturale. Lo scopo di questo componente è quello di presentare in uscita dei valori da dare in input alla macchina che si vuole testare ed inviare un segnale di scrittura per il salvataggio dei risultati.Il sistema è composto da:
\\\\{\large \textbf{Gestore read:}}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.55\textwidth,height=0.55\textheight,keepaspectratio]{\Esei gestore_read_entity.png}
\end{figure}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.55\textwidth,height=0.55\textheight,keepaspectratio]{\Esei gestore_read_archit.png}
    \caption{Gestore Read}
\end{figure}
\clearpage
A partire dal segnale ripulito di READ viene prodotto un segnale di OUT\_READ  che rimane alto per tanti periodi di clk quanti sono gli input di test: $N \cdot Tclk$. E’ realizzato come una macchina a stati:
\begin{itemize}
    \item Stato NOTREAD: in tale state il valore di out\_read è pari a 0 e rimane in attesa di un segnale cleared\_read, appena questo arriva si passa nello stato di READ.
    \item Stato READ: a tale stato è associata l’uscita out\_read pari a 1; il sistema rimane in questo stato per N colpi di clock per poi tornare allo stato NOTREAD.
\end{itemize}
{\large \textbf{ROM:}}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.9\textwidth,height=\textheight,keepaspectratio]{\Esei rom_entity.png}
\end{figure}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.9\textwidth,height=\textheight,keepaspectratio]{\Esei rom_process.png}
    \caption{ROM}
\end{figure}
\clearpage
E’ stata realizzata come una memoria precaricata, che all’arrivo del segnale di read visualizza in uscita il valore puntato ed incrementa il puntatore ai valori memorizzati. Il generic permette di memorizzare i valori al variare della variabile N.
\\{\large \textbf{DELAY:}}
\\Il blocco di delay è necessario per poter ritardare il segnale di write in memoria, in questo modo si sincronizza l’uscita della macchina combinatoria al segnale di scrittura. Si suppone che la macchina combinatoria abbia un ritardo inferiore al $Tclock\over{2}$; se così non fosse allora dovremmo aumentare il periodo del clock con un divisore in frequenza.
\begin{figure}[ht!]
    \centering
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Esei delay_block.png}
    \caption{Delay Block}
\end{figure}
\\Il blocco di delay e la ROM agiscono sul fronte di discesa del clock in modo che il ritardo ottenuto sia tale da campionare il valore di uscita della macchina quando è stabile e non sulla transizione. Il segnale di write, infatti, varia sul fronte di discesa del clock, mentre la scrittura in memoria avviene sul fronte di salita.
\\\\Memoria: è realizzata in maniera comportamentale. La scrittura avviene con la delay\_write (che dura $N \cdot Tclk$), quindi permette di scrivere N valori in uscita dalla macchina combinatoria. La lettura avviene con la read\_gestore (che dura Tclk), la quale permette di scorrere i valori in memoria con periodo di 1s. Agiscono due puntatori: uno per la lettura ed uno per la scrittura.
\begin{figure}[ht!]
    \centering
    \includegraphics[width=\textwidth,height=0.7\textheight,keepaspectratio]{\Esei memoria_esterna.png}
    \caption{Memoria Esterna}
\end{figure}
\\{\large \textbf{Gestore Led:}}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.7\textwidth,height=\textheight,keepaspectratio]{\Esei gestore_led_entity.png}
\end{figure}
\clearpage
È realizzato come una macchina a stati che gestisce la visualizzazione degli output, visualizzandoli ad intervalli di 1s. Il generic N permette di gestire, tramite una variabile count, l’intervallo di visualizzazione degli output. Il generic X permette di stabilire, tramite la variabile count\_valori, il numero di valori da visualizzare.
\begin{figure}[ht!]
    \includegraphics[width=0.6\textwidth,height=\textheight,keepaspectratio]{\Esei gestore_led_archit1.png}
\end{figure}
\begin{figure}[ht!]
    \includegraphics[width=0.75\textwidth,height=\textheight,keepaspectratio]{\Esei gestore_led_archit2.png}
    \caption{Gestore Led}
\end{figure}
\clearpage
Lista di stati:
\begin{itemize}
    \item Stato q0: è lo stato in cui si arriva dopo ogni segnale di RESET o dopo la visualizzazione completa dei valori in memoria. Vengono resettati i valori di count, count\_valori e si rimane in attesa di un segnale di READ per poter passare allo stato q\_ready.
    \item Stato q\_ready: si confronta il valore di count\_valori con 0 per poter stabilire se è la prima iterazione, in questo caso si aspetta che la macchina elabora i dati in ingresso per poi passare alla visualizzazione effettiva, altrimenti si alza il segnale di lettura della memoria. Si incrementa, poi, il valore di count\_valori e si passa allo stato q\_ready2.
    \item Stato q\_ready2: si abbassa il segnale di lettura della memoria e si mostrano i risultati, attendendo un numero di impulsi di clock pari ad N tramite la variabile count, prima di procedere alla visualizzazione del risultato successivo. Si effettua, poi, un controllo per stabilire se il valore visualizzato è l’ultimo o meno tramite count\_valori: se è così, allora si passa allo stato di q0;  altrimenti si passa in q\_ready.
\end{itemize}
\subsection{Simulazione e Sintesi}
Simulazione:
\begin{figure}[ht!]
    \centering
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Esei simulazione.png}
    \caption{Simulazione Es.6}
\end{figure}
\clearpage
Sintesi su FPGA:
\\Per la sintesi su fpga sono stati inseriti i debouncer per i pulsanti di READ e RESET.
\begin{figure}[ht!]
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Esei board.jpg}
    \caption{Sintesi Es.6}
\end{figure}
\clearpage
\section{Esercizio 7 - Comunicazione Handshaking}
\subsection{Introduzione all'handshaking}
Nella comunicazione tra due entità, generalmente, si individua un’entità che trasmette i dati, chiamata master, ed un’entità che riceve ed elabora i dati, chiamata slave. Per far interagire correttamente il master e lo slave bisogna prendere in considerazione 2 fattori: la presenza o meno di un criterio di asservimento e la definizione di un criterio di riferimento temporale.
Quando l’entità slave è completamente asservita all’entità master, quest’ultima non deve preoccuparsi dell’istante di tempo in cui inviare i dati, dato che l’entità slave sarà sempre pronta a ricevere nuovi dati. In questo caso, quindi, non vi è la necessità di introdurre alcun segnale aggiuntivo per instaurare una comunicazione, ma basterà immettere i dati sul canale (al più si può pensare di utilizzare un segnale di strobe per evidenziare l’effettiva presenza dei dati).
\\Tuttavia, non sempre tra 2 entità l’asservimento è assoluto, e dunque, bisogna assicurarsi che, quando l’entità master vuole iniziare una nuova trasmissione, l’entità slave sia a sua volta disponibile.
Oltre ad un problema di asservimento, in genere, sussiste un problema di riferimento temporale, il quale nasce quando le 2 entità che devono interagire si trovano su 2 schede differenti, e dunque non possono essere fatte considerazioni sui riferimenti temporali. Infatti, anche se le 2 schede presentano clock isofrequenziali, non è detto che i riferimenti temporali siano analoghi, dato che questi possono variare per via alla fase iniziale.
Al fine di risolvere queste problematiche e garantire una corretta comunicazione tra 2 entità, si utilizza un protocollo di comunicazione basato su handshaking, che nel senso letterale indica una “stretta di mano” prima di avviare la comunicazione, il quale si basa sull’ipotesi che sia sempre il master ad inviare dati sul canale.
\\Di un protocollo basato su handshaking vi sono più implementazioni, le quali differiscono per le modalità di inizio della comunicazione e, di conseguenza, per il numero di segnali trasmessi sul canale.
Il protocollo più semplice è quello che prevede un segnale strobe da parte del master, che, come detto, evidenzia la presenza di dati sul canale, ed un segnale di risposta (generalmente chiamato di acknowledgment) da parte dello slave, il quale indica la corretta ricezione dei dati e può essere inviato sia appena ricevuti i dati, sia dopo la loro elaborazione.
Una implementazione di questo tipo è utile per risolvere un problema di riferimento temporale, ma può non essere adatta a comunicazione prive di asservimento, per le quali generalmente si fa uso di un protocollo basato su handshake interlacciato.
\\L’handshaking interlacciato prevede la verifica della disponibilità dello slave alla ricezione di nuovi dati, prima di immettere quest’ultimi sul canale. In tale implementazione, quando il master vuole inviare dei dati, prima invia un segnale di request allo slave, il quale, se disponibile, invia a sua volta un segnale di risposta. A questo punto parte la comunicazione.
Un ulteriore protocollo di handshaking, definito semisincrono, viene utilizzato quando lo slave deve inviare un dato di risposta al master, e prevede un ulteriore segnale per indicare quando l’elaborazione è terminata ed il dato di risposta è effettivamente presente sul canale. Si parla di protocollo semi sincrono poiché, il master, vede il segnale solo in corrispondenza di un colpo di clock (un protocollo di questo tipo è generalmente implementato nella comunicazione tra il processore e la memoria cache).
\\Come detto all’inizio della trattazione, in genere il master e lo slave lavorano con 2 clock differenti: un protocollo di handshaking prevede che, la frequenza del riferimento temporale dello slave, sia N volte quella del master, in modo da riuscire a campionare il segnale ricevuto anche nel caso di sfasamenti del clock.
Entrando ora nel merito dell’esercizio, si è deciso di implementare un protocollo con handshaking di tipo semisincrono.
\\\\{\large \textbf{Approccio Utilizzato}}
\\L’esercizio in esame prevede 2 sistemi, A e B, dove il sistema A deve inviare N valori al sistema B il quale, a sua volta, dovrà sommare tali valori a quelli contenuti in memoria per poi salvare il risultato in ulteriori locazioni della memoria stessa.
Entrambi i sistemi sono stati definiti mediante un approccio strutturale, dove l’elemento principale è l’interfaccia dei 2 sistemi, la quale è responsabile dell’implementazione del protocollo di handshaking. Prima di passare alla descrizione dei 2 sistemi, nel paragrafo successivo verrà descritto il protocollo di handshaking implementato.
\\\\{\large \textbf{Descrizione Protocollo}}
\\Il protocollo di handshaking implementato prevede un segnale r, ovvero di request, alzato dal sistema A (il master), il quale indica la volontà di trasmettere dei dati, ed un segnale di ris, alzato dal sistema B(lo slave) in ricezione del segnale di request, che indica la disponibilità nel ricevere i dati e che rimarrà alto fino alla completa elaborazione di quest’ultimi.
La variazione da 1 a 0 del segnale di ris indica, dunque, la completa elaborazione dei dati da parte dello slave e viene interpretata dal master come la possibilità di inoltrare nuovi dati.
L’handshake avviene prima della trasmissione di ogni dato.
Vediamo ora come i 2 sistemi implementano tale protocollo.
\begin{figure}[ht!]
    \centering
    \includesvg[width=\textwidth,height=\textheight]{\Esette sistema_completo.svg}
    \caption{Schema Sistema Completo Es.7}
\end{figure}
\clearpage
%{\large \textbf{SistemaA:}}
\subsection{Sistema A}
Come precedentemente detto, il sistema A è stato definito tramite un approccio strutturale, utilizzando i seguenti componenti:
\begin{itemize}
    \item Una memoria ROM dove vengono salvati i valori X(i);
    \item Un'interfaccia per effettuare l'handshaking e la trasmissione;
    \item Un contatore che segna il numero di comunicazioni già avvenute.
\end{itemize}
L’interfaccia rappresenta la parte di controllo mentre il contatore e la rom compongono la parte operativa.
\begin{figure}[ht!]
    \centering
    \includesvg[width=0.9\textwidth,height=\textheight]{\Esette sistema_a.svg}
    \caption{Schema Sistema A Es.7}
\end{figure}
\\Il sistema ripete la stessa sequenza di operazioni per ogni valore X(i) contenuto in ROM.
\\Alla comunicazione i-esima, l'interfaccia invia un segnale di read per leggere il valore X(i) puntato dal valore del contatore. Una volta letto il valore, l'interfaccia pone in uscita i dati per iniziare la nuova comunicazione e alza il segnale di R; abbassa tale segnale solo dopo l'arrivo del RIS. Finchè RIS resta alto, il sistema A non può iniziare una nuova comunicazione, per questo rimane in attesa che il ricevitore finisca di elaborare i dati, cioè che RIS si abbassi. Appena RIS = 0 allora posso iniziare la nuova comunicazione i+1.
\\Appena si raggiungono le N comunicazioni il segnale di DIV in uscita al contatore si alza e termina la comunicazione complessiva tra il sistema A e B dal lato del trasmettitore.
\clearpage
\subsubsection{Unità Operativa A}
{\large \textbf{Componente contatore:}}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Esette entity_contatore.png}
    \caption{Entity Contatore}
\end{figure}
\\E' descritto come una macchina a stati che conta il numero di comunicazioni effettuate. A partire da un segnale di ris, il contatore conta quante volte questo si alza, ossia i fronti di salita:
\begin{enumerate}
    \item q0 $\rightarrow$ stato in cui se il segnale in ingresso al contatore è basso allora resto in q0, altrimenti effettuo l'incremento del contatore in modulo N e mi sposto nello stato q1. Se raggiungo la fine del conteggio ossia count = N-1 allora alzo DIV (segnale di stop).
    \item q1 $\rightarrow$ stato in cui aspetto che il segnale in ingresso si abbassi: se rimane alto, allora resto in q1, altrimenti passo in q0;
\end{enumerate}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.8\textwidth,height=\textheight,keepaspectratio]{\Esette architecture_counter.png}
    \caption{Architecture Contatore}
\end{figure}
\clearpage
{\large \textbf{Componente Rom:}}
\begin{figure}[ht]
    \centering
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Esette entity_rom.png}
\end{figure}
\\E' progettato come una semplice memoria, che sul fronte di salita del clock valuta il segnale di read: se questo è alto, pone in uscita il dato presente alla locazione indicata dal valore del counter.
\begin{figure}[ht!]
    \centering
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Esette architecture_rom.png}
    \caption{Architecture ROM}
\end{figure}
\clearpage
\subsubsection{Unità di Controllo A}
{\large \textbf{Componente interfaccia:}}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Esette entity_interfacciaa.png}
    \caption{Entity Interfaccia A Es.7}
\end{figure}
\\L’interfaccia è il componente che gestisce l’handshaking e la trasmissione dei dati sul canale. È stata progettata come una macchina a 7 stati, dove:
\begin{enumerate}
    \item q0 $\rightarrow$ è lo stato iniziale, dove ci si ritrova prima della trasmissione oppure al termine. Per distinguere i 2 casi si utilizza il segnale di div in uscita dal contatore: quando è basso, indica che ancora non abbiamo trasferito il primo dato (dato che differenziamo la prima trasmissione dalle altre e, dunque, in q0 si valuta solo la prima), mentre, quando è alto, indica che tutti i dati sono stati trasmessi e si permane indefinitamente in q0.
          Quando il segnale di div è basso, si passa il q1 e viene alzato il segnale di read, in modo da leggere dalla memoria il valore da trasmettere.
    \item q1 $\rightarrow$ viene abbassato il segnale di read, dato che deve durare solo 1 colpo di clock, al fine di evitare letture spurie in memoria. Si passa poi nello stato q2.
          Anche se può sembrare superfluo, lo stato q1 è necessario, per dare il tempo al componente memoria di porre in uscita il dato i-esimo.
    \item q2 $\rightarrow$ siamo ora sicuri che il dato in uscita dalla memoria è quello corretto: possiamo dunque riporlo sul canale ed alzare il segnale r. Si passa ora nello stato q3.
    \item q3 $\rightarrow$ tale stato è sostanzialmente di attesa: finchè non si alza il segnale di ris in ingresso, si permane in q3. Quando invece tale segnale viene rilevato come alto, i dati sono stati acquisiti dal sistema B e si può passare dunque allo stato q4.
    \item q4 $\rightarrow$ quando ci si ritrova in questo stato, si è sicuri che il sistema B ha ricevuto i dati inviati: si abbassa dunque il segnale di r e si passa allo stato q5.
    \item q5 $\rightarrow$ tale stato è sostanzialmente analogo a q0, solo che viene utilizzato per le trasmissioni successive alla prima. Si valuta quindi il segnale di div e, se alto, si procede verso q0, altrimenti si alza il segnale di read e si procede verso q6. È bene notare che, tali controlli sul segnale di div, potevano essere fatti anche in q4; tuttavia, dato che il contatore si incrementa sul segnale di ris in ingresso al sistema, si è preferito aggiungere uno stato per essere sicuri di vedere tale segnale stabile.
    \item q6 $\rightarrow$ se ci ritroviamo in questo stato, vuol dire che si deve procedere ad una trasmissione successiva alla prima. Per questo motivo si controlla il segnale di ris: se questo è basso, allora la precedente elaborazione è terminata e si può procedere ad inviare i nuovi dati, passando allo stato q2, mentre, se alto, si permane in q6 in attesa che si abbassi.
\end{enumerate}
\clearpage
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.55\textwidth,height=\textheight,keepaspectratio]{\Esette arc_inta_1.png}
\end{figure}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.55\textwidth,height=\textheight,keepaspectratio]{\Esette arc_inta_2.png}
    \caption{Architecture Interfaccia A Es.7}
\end{figure}
\clearpage
\subsection{Sistema B}
Il Sistema B è stato definito tramite un approccio strutturale, utilizzando i seguenti componenti:
\begin{itemize}
    \item Un’interfaccia, la quale comunica con il sistema A, gestisce i segnali di r e ris e acquisisce i dati da elaborare;
    \item Un contatore per indicare la terminazione dei dati da ricevere;
    \item Una control unit, che ha il compito di effettuare le operazioni sui dati ricevuti e di salvarli in memoria;
    \item Una memoria unica con i dati da sommare a quelli ricevuti dal sistema A e ulteriori locazioni per salvare i risultati.
\end{itemize}
Anche per tale sistema, l’interfaccia rappresenta la parte di controllo mentre la memoria, il contatore e la control unit compongono la parte operativa. Il nome control-unit può risultare confusionale, ma è stato dato poiché elabora i dati e controlla il componente memoria.
\begin{figure}[ht!]
    \centering
    \includesvg[width=0.9\textwidth,height=\textheight]{\Esette sistema_b.svg}
    \caption{Schema Sistema B Es.7}
\end{figure}
\clearpage
\subsubsection{Unita Operativa B}
{\large \textbf{Componente Control Unit:}}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.55\textwidth,height=\textheight,keepaspectratio]{\Esette entity_controlunitb.png}
    \caption{Entity Control Unit}
\end{figure}
\\La control unit è responsabile dell’elaborazione dei dati ricevuti e della collocazione dei risultati all’interno della memoria. Anch’essa è stata definita come una macchina a stati, dove:
\begin{enumerate}
    \item q0 $\rightarrow$ è lo stato in cui la macchina permane fino alla ricezione del primo dato da elaborare, rimanendo in attesa della variazione da 0 a 1 del segnale di ab\_control modificato dall’interfaccia.
          Quando rileva tale variazione passa allo stato q1 ed abbassa l’ab\_interfaccia.
    \item q1 $\rightarrow$ in tale stato si ripone il segnale di read a 1  e si passa allo stato q2.
    \item q2 $\rightarrow$ dato che il segnale di read si vuole che duri un singolo colpo di clock, in questo stato viene abbassato e si passa poi allo stato q3.
    \item q3 $\rightarrow$ in tale stato si è sicuri che i dati da elaborare sono entrambi disponibili e corretti, motivo per cui vengono immagazzinati come unsigned all’interno di appositi signal, tramite i quali si eseguirà poi una operazione di somma. In questo stato si pone a 1 il segnale di ab\_interfaccia, il quale verrà letto al colpo di clock dopo dall’interfaccia che abbasserà il segnale di ris. Anche se l’elaborazione non è del tutto terminata, si inizia a dare tale segnale dato che al colpo di clock dopo si avrà effettivamente la completa elaborazione e, comunque, il segnale ab\_interfaccia verrà rilevato al colpo di clock successivo. Si passa infine allo stato q4.
    \item q4 $\rightarrow$ viene alzata la write e posto sul segnale s il valore della somma, il quale verrà salvato nella memoria; si pone inoltre a 0 il segnale di ab\_interfaccia. Quest’ultima operazione può risultare ambigua, dato che porre a 0 tale segnale vuol dire disabilitare l’interfaccia, che in questo caso però deve essere attiva e pronta a ricevere ed inoltrare nuovi dati. Ciò che è bene notare, però, è che l’interfaccia valuta il segnale di ab\_interfaccia solo in alcuni stati e, la variazione di tale segnale permette comunque di proseguire verso alcuni stati, ma la mette in attesa negli stati in cui è giusto che l’interfaccia si fermi una volta ricevuti i dati. Stiamo sostanzialmente dicendo all’interfaccia che, quando arriverà nuovamente in uno di quegli stati dovrà fermarsi e non che in generale non deve lavorare. Si passa infine allo stato q5.
    \item q5 $\rightarrow$ tale stato ha sostanzialmente lo stesso scopo dello stato q4 nell’interfaccia, ovvero quello di replicare lo stato q0 quando però non si è al primo dato da elaborare. Le operazioni sono dunque analoghe a quelle dello stato q0, con l’aggiunta della variazione da 1 a 0 del segnale di write, il quale, come il segnale di read, deve durare 1 colpo di clock.
\end{enumerate}
\clearpage
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.55\textwidth,height=\textheight,keepaspectratio]{\Esette arc_control_b1.png}
\end{figure}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.55\textwidth,height=\textheight,keepaspectratio]{\Esette arc_control_b2.png}
    \caption{Entity Control Unit}
\end{figure}
\clearpage
{\large \textbf{Componente Counter:}}
\\Tale contatore è impostato sul fronte di salita del clock e incrementa solo quando il segnale di ab\_interfaccia si alza, ovvero quando è terminata l’elaborazione del dato. Siccome tale segnale si alza un colpo di clock prima dell’effettiva terminazione, è stato introdotto un blocco di delay per salvare i valori nella giusta locazione di memoria.
\\Tale componente è analogo al contatore utilizzato nel sistema A, ovvero progettato come una macchina a stati; varia solamente il segnale che riceve in ingresso.
\\\\{\large \textbf{Componente Memoria:}}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Esette entity_memoriab.png}
\end{figure}
\\Tale componente è stato descritto in modo comportamentale ed è uguale al componente utilizzato nell’esercizio 5. Tuttavia, per completezza, riportiamo nuovamente la sua implementazione.
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.75\textwidth,height=\textheight,keepaspectratio]{\Esette architecture_memoriab.png}
    \caption{Architecture Memoria B}
\end{figure}
\clearpage
\subsubsection{C B}
{\large \textbf{Componente Interfaccia:}}
\begin{figure}[ht]
    \centering
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Esette entity_interfacciab.png}
    \caption{Interfaccia B}
\end{figure}
L’interfaccia è stata definita come una macchina a 5 stati, dove:
\begin{enumerate}
    \item q0 $\rightarrow$ E' lo stato in cui si trova l’interfaccia prima di ricevere il primo dato da elaborare. In questo stato, si attende la variazione del dato in input r, ricevuto dal sistema A, la cui variazione da 0 a 1 indica la disponibilità dei dati da elaborare. Finché r è basso, l’interfaccia permane in q0 e, quando rileva la variazione sul fronte di salita del clock, acquisisce i dati, alza il segnale di ris in uscita ( il quale viene visto dal sistema A ed è indice che i dati sono stati prelevati e che l’elaborazione di B è iniziata) ed abilita il segnale di ab\_control, che mette in attesa l’interfaccia stessa durante l’elaborazione dei dati da parte della control unit. Passa infine nello stato q1.
    \item q1 $\rightarrow$ In tale stato l’interfaccia permane finché non vede una variazione da 0 a 1 del segnale ab\_interfaccia, il quale viene fatto variare dalla control unit una volta terminata l’elaborazione dei dati ricevuti. Quando viene rilevata la variazione su tale segnale, l’interfaccia abbassa il segnale ab\_control, disabilitando così la control unit fino alla ricezione di nuovi dati. Passa infine nello stato q2.
    \item q2 $\rightarrow$ La prima operazione che si effettua in questo stato è la valutazione del segnale r, verificando se questo è ancora alto o meno. Tale operazione potrebbe risultare inutile, dato che il sistema A abbassa tale segnale nel momento in cui vede il segnale di ris alzarsi, ma così non è. Bisogna ricordare infatti che il sistema B lavora in genere con un clock a frequenza maggiore (o semplicemente con fase diversa) e potrebbe quindi svolgere le operazioni in maniera molto rapida e non dare il tempo al sistema A di abbassare tale segnale. Se non venisse effettuato tale controllo, negli stati successivi si potrebbe interpretare il segnale di r pari ad 1 come indice di nuova trasmissione, portando alla rielaborazione di dati già processati.
          \\L’interfaccia pertanto rimane in tale stato finché non rileva una variazione da 1 a 0 del segnale di r; quando tale segnale varia, abbassa il segnale di ris e passa nello stato q3.
          \\Valutare il segnale r prima di abbassare quello di ris risolve inoltre un altro problema: dato che il segnale di ris viene valutato dal sistema A, così facendo, si fa in modo che duri almeno 1 colpo di clock di A, in modo che quest’ultimo possa rilevarne le variazioni, indipendentemente dal numero di operazioni effettuate dal sistema B.
    \item q3 $\rightarrow$ Tale stato è il responsabile del controllo dei dati rimanenti da elaborare. Se il segnale di div in uscita dal contatore è alto, allora vuol dire che il dato appena elaborato era l’ultimo e l’interfaccia torna dunque nello stato q0. In caso contrario si procede verso lo stato q4.
    \item q4 $\rightarrow$ Questo stato è sostanzialmente l’analogo dello stato q0, ma quando si sono già ricevuti dei dati.  È necessario introdurre questo tipo di stato per effettuare un controllo sul numero di elaborazioni effettuate per determinare la terminazione di esse.
\end{enumerate}
\clearpage
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.65\textwidth,height=\textheight,keepaspectratio]{\Esette arc_inter_b1.png}
\end{figure}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.45\textwidth,height=\textheight,keepaspectratio]{\Esette arc_inter_b2.png}
    \caption{Architecture Interfaccia B Es.7}
\end{figure}
\clearpage
\subsection{Considerazioni Finali}
Per come è stato implementato, il protocollo è efficiente con $f_B=N \cdot f_A$ per ogni valore di N (si da per scontato che il clock di B permette l’assestamento dei segnali in 1 colpo di clock).
\\In questo modo, non serve che il componente master ed il componente slave si accordino sulle frequenze da utilizzare.
\\Nel caso in cui siano noti i riferimenti temporali dei 2 componenti, possono essere ridotti il numero di stati delle interfacce di A e di B.
\\\\{\large \textbf{Simulazione:}}
\\Così come richiesto, è stata effettuata una simulazione del funzionamento del protocollo, con una frequenza $f_B=2 \cdot f_A:$
\begin{figure}[ht!]
    \centering
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Esette sim1.png}
\end{figure}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Esette sim2.png}
    \caption{Simulazione Es.7}
\end{figure}
\clearpage
\section{Esercizio 8 - Processor}
A partire dall’implementazione fornita di un processore operante secondo il modello IJVM:
\begin{enumerate}[label=\alph*.]
    \item Si proceda all’analisi dell’architettura mediante simulazione e si approfondisca lo studio del suo funzionamento per due istruzioni a scelta,
    \item Si modifichi un codice operativo a scelta, documentando tutte le modifiche effettuate,
    \item (opzionale) si descriva il funzionamento del processore in merito alle istruzioni di input/output,
    \item (solo ove possibile) si sintetizzi il processore su FPGA.
\end{enumerate}
\subsection{Introduzione a IJVM}
E’ un linguaggio di livello macchina, semplificazione dell’Instruction Set Architecture JVM. La semplificazione consiste nell’utilizzo di sole operazioni su interi. L’IJVM organizza la memoria suddividendola in:
\begin{itemize}
    \item Constant Pool: area che non permette la scrittura da parte del programma IJVM. I dati qui caricati (costanti, puntatori e stringhe), possono essere scritti solamente quando il programma è portato in memoria ed è accessibile tramite il registro Constant Pool Pointer;
    \item Local Variable Frame: area dove vengono inserite le variabili locali al programma ed i parametri relativi ad esso. L’ indirizzo relativo all’inizio di quest’area è gestito tramite il registro LV;
    \item Stack degli operandi: è localizzato al di sopra del Local Variable Frame e permette di gestire gli operandi durante un’operazione. E’ accessibile tramite il registro SP, il quale punta sempre all’ultima locazione inserita nello stack;
    \item Method Area: area in cui risiedono i programmi IJVM da eseguire. Quest’area della memoria viene gestita come un array di byte, mentre tutte le precedenti sono gestite come array di parole da 4 byte.
\end{itemize}
Per i registri LV,SP e CPP, indicare un offset equivale quindi ad indicare uno spiazzamento di 32 bit, mentre per il PC equivale ad indicare uno spiazzamento di 8 bit.
\clearpage
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.8\textwidth,height=\textheight,keepaspectratio]{\Eotto memoriaIJVM.png}
    \caption{Memoria IJVM}
\end{figure}
Le istruzioni IJVM sono a lunghezza variabile in base alla presenza di operandi o altri parametri; in generale possono occupare da 8 bit a 24 bit e vengono dunque memorizzate nella Method Area in locazioni contigue. Il primo byte di ogni istruzione è il Codice Operativo, ossia un indirizzo che verrà utilizzato per mappare l’istruzione IJVM con l’indirizzo start del microprogramma contenuto nella control\_store del processore.
\\\\{\large \textbf{Esempi di istruzioni IJVM:}}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.7\textwidth,height=\textheight,keepaspectratio]{\Eotto istruzioniIJVM.png}
    \caption{Istruzioni IJVM}
\end{figure}
\clearpage
{\large \textbf{Il processore MIC-1:}}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Eotto mic-1completo.png}
    \caption{Processore MIC-1}
\end{figure}
\\E’ una macchina a stack, ossia che non utilizza registri general purpose (ad esempio di tipo indirizzo o dato), ma le istruzioni presentano operandi contenuti in uno stack allocato nella memoria principale. Il processore MIC-1 è organizzato in parte operativa e parte di controllo.
\clearpage
\subsection{Unità Operativa}
La parte operativa realizza il datapath dell’architettura ed è composto da registri a 32 bit, 3 bus, ALU e shifter, come mostrato in figura:
\begin{figure}[ht!]
    \centering
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Eotto datapath.png}
    \caption{Datapath Processore}
\end{figure}
\clearpage
{\large \textbf{Comunicazione in memoria:}}
\\La comunicazione in memoria differisce in tempificazione se si tratta di una read o di una write. In particolare nel caso della write, nello stesso periodo di clock avviene sia l’acquisizione sulle linee dell’indirizzo che del dato da scrivere in memoria, mentre nel caso della read è necessario un colpo di clk in più per la presentazione del dato in uscita alla memoria.
\begin{figure}[ht!]
    \centering
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Eotto tempificazionemem.png}
    \caption{Tempificazione Memoria}
\end{figure}
\\I registri utilizzati per la comunicazione in memoria si suddividono in coppie:
\begin{itemize}
    \item MAR-MDR: Quest’interfaccia è relativa alle aree di memoria accessibili in parole di 4 byte (Constant Pool,Local Variable, Stack). Questa consente di specificare l’indirizzo in memoria in MAR a partire dal quale leggere o scrivere 4 byte consecutivi nel MDR.
    \item PC-MBR  Quest’interfaccia è relativa all’ aree di memoria in cui è contenuto il programma, la quale è accessibile in parole da 1 byte (Method Area). Questa consente di specificare l’indirizzo in memoria in PC a partire dal quale leggere 1 byte ponendolo nel MBR. Ciò significa che se un’istruzione prevede di specificare sia il codice operativo, che un operando, allora verrà prelevato prima il codice operativo e poi l’operando; le microprocedure sono realizzate tenendo conto proprio di questa modalità di comunicazione della memoria dell’interfaccia PC-MBR.
\end{itemize}
\clearpage
{\large \textbf{Bus:}}
\\\\L’unità operativa dispone di tre bus con parallelismo a 32 bit:
\begin{itemize}
    \item A: per utilizzare un secondo operando ed effettuare le operazioni in ALU;
    \item B: è utilizzato per effettuare la lettura dai registri;
    \item C: utilizzato per la scrittura dei registri;
\end{itemize}
{\large \textbf{ALU:}}
\\\\L’ALU ha due ingressi: A,collegato direttamente al registro tampone H, e B collegato al bus B. Per poter definire l’operazione da effettuare a partire dagli operandi si utilizza una stringa di segnali di controllo di 6 bit. Inoltre, quando il risultato passa nello shifter, vi sono ulteriori 2 segnali che permettono di effettuare lo shift di quest’ultimo, prima che venga posto sul bus C.
\clearpage
\subsection{Unità di Controllo}
E’ realizzata tramite una memoria di sola lettura, detta control store, un microPC ed un microIR. La control store memorizza tutti i microprogrammi relativi alle istruzioni del set IJVM, allocandoli in memoria all’indirizzo corrispondente al codice operativo dell’istruzione.
Ad ogni ciclo di clk, viene continuamente letta dalla control store la microistruzione all’indirizzo puntato dal mPC.
\\\\Il formato delle microistruzioni è dato dalla seguente figura:
\begin{figure}[ht!]
    \centering
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Eotto formatomicroistr.png}
    \caption{Formato Microistruzione}
\end{figure}
\\Ogni microistruzione è legata alla successiva tramite i bit di NEXT\_ADDRESS e i bit di salto JAM. È necessario effettuare questo concatenamento delle microistruzioni poiché, quelle relative allo stesso microprogramma, potrebbero non essere salvate in locazioni contigue della control\_store (si pensi a POP e DUP). Oltre a questo concatenamento è possibile che ci sia la presenza dei salti in base al tipo di microistruzione (ad esempio quando vengono utilizzati i costrutti if, else e goto).
\\In particolare, se JAM = “000”, allora mPC = NEXT\_ADDRESS, altrimenti, se almeno uno dei flag di salto è alto, occorre calcolare il nuovo mPC:
\begin{itemize}
    \item JAMN = 1: il bit più significativo di mPC viene messo in OR  con il flag N dell’ALU (risultato negativo in uscita).
    \item JAMZ = 1: il bit più significativo viene messo in OR con il flag Z dell’ALU (risultato nullo in uscita).
    \item JAMC = 1: gli 8 bit meno significativi di NEXT\_ADDRESS sono messi in OR con MBR. In questo modo ottengo un salto di un valore pari a quello contenuto in MBR.
\end{itemize}
Per caricare la prossima microistruzione è necessario che trascorra un certo intervallo di tempo, necessario al caricamento del nuovo mPC. Il ciclo di clock inizia sul fronte di discesa in cui è disponibile il nuovo valore del mPC, il quale è stato caricato sul fronte di salita dello stesso impulso di clock. E’ necessario scegliere una frequenza adeguata del clock, in modo tale che tutti i ritardi dovuti ai vari componenti del datapath siano contenuti e quindi i segnali sui bus si stabiliscano.
\begin{figure}[ht!]
    \centering
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Eotto clocktiming.png}
    \caption{Timing Clock}
\end{figure}
\clearpage
{\large \textbf{Flusso di esecuzione delle istruzioni:}}
\\Il processore MIC-1 dispone del set di istruzioni relative all’ Integer Java Virtual Machine e sfrutta la logica microprogrammata, ovvero realizza ogni istruzione tramite un microprogramma.
\\Per innescare l’esecuzione di un programma assembler è necessario effettuare prima la traduzione da assembler a microassembler e poi da microassembler a parole di controllo.
\\A partire dal set di istruzioni IJVM, l’assemblatore Java effettua la corrispondenza tra le istruzioni ed i microprogrammi, i quali verranno tradotti dal microassemblatore MAL in sequenze di segnali di controllo rispetto all’architettura MIC-1. Tutte le sequenze generate vengono inserite all’interno della control\_store del processore.
\\Una volta scritto il programma in AJVM, tutte le istruzioni IJVM sono tradotte in sequenze di bit che contengono il codice operativo dell'istruzione, ovvero l’indirizzo start del microprogramma contenuto nella control\_store del processore, ed eventuali operandi. Il programma tradotto viene poi inserito nella memoria del sistema.
\\\\{\large \textbf{Flusso di esecuzione di esempio:}}
\textit{
    \\.main
    \\  .var
    \\a
    \\.endvar
    \\BIPUSH 0xA
    \\BIPUSH 0xE
    \\IADD
    \\ISTORE a
    \\HALT // HALT is a no operand instruction but translates as a GOTO (short value)
    \\.endmethod
}
\clearpage
Per ogni programma vengono eseguite le microprocedure seguenti:
\begin{enumerate}
    \item Viene prima eseguita la routine mic1\_entry, la quale inizializza i registri del datapath ed inizializza la memoria locale del programma.
    \item Viene inizializzato il valore a cui punta LV, il quale contiene l'indirizzo di memoria da cui deve partire lo stack pointer, ossia dopo l'allocazione di memoria per le variabili locali.
    \item Viene poi eseguita la procedura main, ed inizia l'effettivo programma.
\end{enumerate}
{\large \textbf{Flusso di esecuzione BIPUSH:}}
\begin{enumerate}[resume]
    \item Si effettua il push dell'operando 0xA sullo stack. L'op. bipush prevede:
          \begin{enumerate}
              \item Lo spostamento del puntatore SP una cella di memoria in avanti. Il nuovo valore di SP viene poi assegnato al registro MAR;
              \item Fetch della 2a parte dell'istruzione (operando 0xA);
              \item Pone in MDR il valore estratto 0xA ed effettua la scrittura in memoria all'indirizzo MAR, ovvero in cima allo stack;
              \item Go to main
          \end{enumerate}
    \item Si effettua il push dell'operando 0xE sullo stack. L'op. bipush è analoga.
\end{enumerate}
{\large \textbf{Flusso di esecuzione IADD:}}
\begin{enumerate}[resume]
    \item Si effettua l'operazione di IADD, la quale prende gli ultimi due valori nello stack (ossia quello in cima allo stack e quello immediatamente precedente) ed effettuare la somma tra i due, ponendola nello stack alla posizione del primo operando.
          \begin{enumerate}
              \item Decremento lo stack pointer per puntare al valore 0xA, lo assegno a MAR ed effettuo la lettura (in MDR avrò 0xA)
              \item Il registro tampone viene assegnato con il valore in cima allo stack (H = TOS);
              \item Effettuo la somma tra H e MDR e la pongo in MDR. Tale somma è assegnata al registro TOS dato che la cima dello stack è cambiata. Infine viene effettuata la write del risultato sullo stack alla posizione puntata dal registro MAR.
              \item Go to main
          \end{enumerate}
\end{enumerate}
{\large \textbf{Flusso di esecuzione ISTORE:}}
\begin{enumerate}[resume]
    \item si effettua l'operazione di ISTORE, la quale memorizza nella memoria locale del programma il valore dell'operazione.
          \begin{enumerate}
              \item H = LV
              \item In MAR viene inserito l’indirizzo della locazione di memoria nella quale sarà effettuata la store. Tale locazione è ricavata dalla somma tra MBRU (unsigned perchè MBR è un registro a 8 bit ed è necessario che abbia spiazzamento a 32 bit, in modo da essere un indirizzo di memoria) ed il registro H, che contiene il valore di LV.
              \item Si inserisce in MDR il valore che si vuole scrivere in memoria locale, ossia quello della cima dello stack, contenente la somma, e si effettua la scrittura all'indirizzo puntato da MAR.
              \item Si decrementa lo stack pointer effettuando una pop della somma, si legge il nuovo valore da inserire nel TOS e lo si pone in MDR.
              \item Si effettua la fetch per spostarsi all'istruzione successiva, poichè l'istruzione ISTORE necessità di due fetch per poter essere eseguita completamente: una per saltare all'operando ed una per andare all'istruzione successiva (questa viene fatta nel main).
              \item Go to main
          \end{enumerate}
\end{enumerate}
\clearpage
\subsection{Analisi delle istruzioni IADD e ISTORE}
\subsubsection{Istruzione IADD}
\textit{
    \\iadd = 0x65:
    \\\hspace*{2cm} MAR = SP = SP - 1; rd
    \\\hspace*{2cm} H = TOS
    \\\hspace*{2cm} MDR = TOS = MDR + H; wr; goto main
}
\\\\La traduzione in segnali di controllo, rispetto al formato delle microistruzioni descritto precedentemente, è la seguente:
\\ \textbf{Microistruzione 1:}	\hspace*{1cm} \textit{MAR = SP = SP - 1; rd}
\\\hspace*{1cm} next\_address: 102
\\\hspace*{1cm} jmp: 000
\\\hspace*{1cm} alu: 00110110
\\\hspace*{1cm} bus C: 000001001
\\\hspace*{1cm} mem: 010
\\\hspace*{1cm} bus B: 0100
\\ \textbf{Microistruzione 2:} \hspace*{1cm} \textit{ H = TOS}
\\\hspace*{1cm} next\_address: 103
\\\hspace*{1cm} jmp: 000
\\\hspace*{1cm} alu: 00010100
\\\hspace*{1cm} bus C: 100000000
\\\hspace*{1cm} mem: 000
\\\hspace*{1cm} bus B: 0111
\\ \textbf{Microistruzione 3:} \hspace*{1cm} \textit{MDR = TOS = MDR + H; wr; goto main}
\\\hspace*{1cm} next\_address: 6
\\\hspace*{1cm} jmp: 000
\\\hspace*{1cm} alu: 00111100
\\\hspace*{1cm} bus C: 001000010
\\\hspace*{1cm} mem: 100
\\\hspace*{1cm} bus B: 0000
\clearpage
{\large \textbf{Simulazione IADD}}

\vspace{0.5cm}
Programma ajvm associato:
\textit{
    \\.main
    \\.var
    \\a
    \\.endvar
    \\BIPUSH 0xA
    \\BIPUSH 0xE
    \\IADD
    \\HALT // HALT is a no operand instruction but translates as a GOTO (short value)
    \\.endmethod
}
\vspace{3cm}
\begin{figure}[ht]
    \centering
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Eotto iadd.png}
    \caption{Simulazione IADD}
\end{figure}
\clearpage
Dalla simulazione si nota che all’esecuzione dell’istruzione IADD (0x36) vengono estratti: 0xA, decrementando lo stack pointer a 0x105, 0xE che viene mantenuto nel registro TOS e viene poi effettuata la somma tra 0xA e 0xE che produce in uscita 0x18, che verrà scritto sulla cima dello stack all’indirizzo 0x105, con un ritardo dovuto al posizionamento nei registri dei valori degli operandi e dalla scrittura in memoria. La simulazione termina appena PC raggiunge il valore 0xB.
\begin{figure}[ht!]
    \centering
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Eotto iadd_flusso.png}
    \caption{Datapath esecuzione IADD}
\end{figure}
\clearpage
\subsubsection{Istruzione ISTORE}
\textit{
    \\istore = 0x36:
    \\\hspace*{2cm} H = LV
    \\\hspace*{2cm} MAR = MBRU + H
    \\istore\_cont:
    \\\hspace*{2cm} MDR = TOS; wr
    \\\hspace*{2cm} SP = MAR = SP - 1; rd
    \\\hspace*{2cm} PC = PC + 1; fetch
    \\\hspace*{2cm} TOS = MDR; goto main
}
\vspace*{1cm}\\La traduzione in segnali di controllo, rispetto al formato delle microistruzioni descritto precedentemente, è la seguente:
\\\\\\\textbf{Microistruzione 1:}	\hspace*{1cm} \textit{H = LV}
\\\hspace*{1cm} next\_address: 55
\\\hspace*{1cm} jmp: 000
\\\hspace*{1cm} alu: 00010100
\\\hspace*{1cm} bus C: 100000000
\\\hspace*{1cm} mem: 000
\\\hspace*{1cm} bus B: 0101
\\ \textbf{Microistruzione 2:}	\hspace*{1cm} \textit{MAR = MDRU + H}
\\\hspace*{1cm} next\_address: 56
\\\hspace*{1cm} jmp: 000
\\\hspace*{1cm} alu: 00111100
\\\hspace*{1cm} bus C: 000000001
\\\hspace*{1cm} mem: 000
\\\hspace*{1cm} bus B: 0011
\\ \textbf{Microistruzione 3:}	\hspace*{1cm} \textit{MDR = TOS; wr}
\\\hspace*{1cm} next\_address: 57
\\\hspace*{1cm} jmp: 000
\\\hspace*{1cm} alu: 00010100
\\\hspace*{1cm} bus C: 000000010
\\\hspace*{1cm} mem: 100
\\\hspace*{1cm} bus B: 0111
\\ \textbf{Microistruzione 4:}	\hspace*{1cm} \textit{SP = MAR = SP - 1; rd}
\\\hspace*{1cm} next\_address: 58
\\\hspace*{1cm} jmp: 000
\\\hspace*{1cm} alu: 00110110
\\\hspace*{1cm} bus C: 000001001
\\\hspace*{1cm} mem: 010
\\\hspace*{1cm} bus B: 0100
\\ \textbf{Microistruzione 5:}	\hspace*{1cm} \textit{PC = PC + 1; fetch}
\\\hspace*{1cm} next\_address: 59
\\\hspace*{1cm} jmp: 000
\\\hspace*{1cm} alu: 00110101
\\\hspace*{1cm} bus C: 000000100
\\\hspace*{1cm} mem: 001
\\\hspace*{1cm} bus B: 0001
\\ \textbf{Microistruzione 6:}	\hspace*{1cm} \textit{TOS = MDR; goto main}
\\\hspace*{1cm} next\_address: 6
\\\hspace*{1cm} jmp: 000
\\\hspace*{1cm} alu: 00010100
\\\hspace*{1cm} bus C: 001000000
\\\hspace*{1cm} mem: 000
\\\hspace*{1cm} bus B: 0000
\\\\{\large \textbf{Simulazione ISTORE}}

\vspace{0.5cm}
Programma AJVM associato:
\textit{
    \\.main
    \\.var
    \\a
    \\.endvar
    \\BIPUSH 0xA
    \\ISTORE
    \\HALT // HALT is a no operand instruction but translates as a GOTO (short value)
    \\.endmethod
}
\clearpage
\begin{figure}[ht]
    \centering
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Eotto istore.png}
    \caption{Simulazione ISTORE}
\end{figure}
Dalla simulazione si nota che:
\begin{itemize}
    \item Viene caricato il registro H con il valore di LV, ossia 0x101;
    \item All’indirizzo base LV viene aggiunto l’offset di 0x01 per puntare alla variabile A nel Local Variable Frame e viene inserito nel MAR ottenendo 0x102;
    \item Si effettua poi la write in memoria all’indirizzo 0x102 del valore in TOS, ossia 0xA;
    \item Si decrementa poi lo stack pointer a 0x104 e si riaggiornano i registri.
\end{itemize}
\clearpage
\begin{figure}[ht]
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Eotto istore1flusso.png}
\end{figure}
\begin{figure}[ht]
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Eotto istore2flusso.png}
    \caption{Datapath esecuzione ISTORE}
\end{figure}
\clearpage
\subsubsection{Modifica istruzione IADD}
E’ stato modificato il microprogramma relativo all’istruzione IADD in questo modo:
\textit{
    \\iadd = 0x65:
    \\\hspace*{2cm} MAR = SP = SP - 1; rd
    \\\hspace*{2cm} H = TOS
    \\\hspace*{2cm} H = H+1
    \\\hspace*{2cm} MDR = TOS = MDR + H; wr; goto main
}
\\L’istruzione di IADD, oltre ad effettuare la somma tra i due operandi, effettua anche l’incremento di 1 al valore ottenuto. Nel microprogramma viene incrementato di 1 il valore dell’operando in cima allo stack, contenuto nel registro H. L’istruzione IADD, in questo caso, impiegherà un ciclo di clk in più ad essere eseguita, per via della microistruzione di incremento.
\\Il programma AJVM associato alla istruzione IADD è lo stesso precedente.
\\\\{\large \textbf{Simulazione IADD Modificata}}
\begin{figure}[ht]
    \centering
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Eotto iaddmodificata.png}
    \caption{Simulazione IADD Modificata}
\end{figure}
\\Dalla simulazione si nota che l’esecuzione dell’istruzione IADD (0x36) è esattamente uguale a quella precedente, se non per l’incremento intermedio del valore in cima allo stack, che passa da 0xE a 0xF.

\clearpage
\section{Esercizio 9 - Interfaccia UART}
\subsection{Introduzione all'UART}
L’UART (Universal Asynchronous Receiver-Transmitter) è un dispositivo hardware che converte flussi di bit di dati da un formato parallelo ad uno seriale e viceversa e, generalmente, è parte di un circuito integrato.
\\Il componente findamentale di tale dispositivo è uno shift register, il quale ci permette di convertire frame paralleli in seriali e viceversa.
\\Il protocollo di trasmissione implementato dall’UART è di tipo asincrono ed il frame trasmesso è composto da:
\begin{itemize}
    \item 1 bit di start
    \item 8 bit su cui è espresso il carattere
    \item 1 bit di controllo
    \item 1 o più bit di stop
\end{itemize}
Implementando un protocollo di tipo asincrono, a differenza di uno sincrono, manca la serie di byte iniziali che definisce proprio il sincronismo tra le 2 entità che vogliono comunicare.
\\Quando non ci sono dati da trasmettere, la linea dati si definisce “a riposo” ed è impostata sul livello logico alto; appena invece ci sono nuovi dati da trasmettere, il valore logico passa da 1 a 0, per poi trasmettere effettivamente il dato.
\\La trasmissione parte, dunque, con un valore logico basso e, di conseguenza, termina con valore logico alto: ciò implica che ci saranno almeno 2 variazioni del segnale durante la trasmissione.
\\Al fine di interpretare i dati trasmessi correttamente, il dispositivo in ricezione deve capire, in un intervallo di tempo, quanti bit ha ricevuto; per tale motivo, i 2 dispositivi devono accordarsi su alcuni parametri della trasmissione:
\begin{itemize}
    \item Velocità dei bit (baud rate)
    \item Numero di bit per carattere
    \item Numero di bit di stop
    \item Numero di bit di parità
\end{itemize}
Generalmente, il numero di bit totali trasmessi è pari a 10, con 8 bit per carattere, un bit di start, uno di stop e nessun bit di parità.
\\Il bit di parità è un metodo di rilevamento, ma non di correzione, di un errore avvenuto su un numero dispari di bit, che prevede l’aggiunta di un bit al termine del carattere, in modo che il numero di bit alti all’interno del dato sia pari.
\\Tale errore, noto come parity error, non è però l’unico che potrebbe verificarsi; ci sono infatti altri 2 tipi di errore da tenere in considerazione:
\begin{itemize}
    \item Overrun error: si verifica quando il destinatario sta ancora elaborando il dato precedente e ne riceve uno nuovo; tale errore porta alla perdita del dato.
    \item Farming error: dopo la rilevazione di tutti i bit relativi al carattere, il dispositivo in ricezione si aspetta un bit di stop; se questo non arriva, vuol dire che c’è stato un errore di campionamento oppure un errore durante la trasmissione.
\end{itemize}
Per evidenziare la presenza di errori, tuttavia, il dispositivo in ricezione deve essere sicuro di campionare correttamente i valori ricevuti; a questo scopo, la parte in ricezione dell’uart lavora con un clock interno a frequenza molto più alta (in genere 16 volte), in modo da campionare il valore trasmesso “al centro”, distante da fasi transitorie.
\\Le 2 frequenze di clock presenti vengono implementate mediante degli stati di wait nelle FSM e gestiti tramite i valori di baud rate e baud divide presenti nell’implementazione.
\\Un ulteriore modo per valutare se il bit ricevuto è pari a 0 o 1 è quello di campionare il dato N volte in ingresso tramite il clock e contare il numero di volte in cui leggo 0 e 1: il valore che leggo più volte sarà quello che salvo.
\\Un’implementazione di questo tipo è però più costosa della precedente e raramente viene implementata; in genere si preferisce ritrasmettere il dato piuttosto che effettuare tali controlli.
\\Al termine di questa breve introduzione sul funzionamento dell’UART, vediamo ora ingressi ed uscite relative alla parte di ricezione e di trasmissione.
\clearpage
{\large \textbf{Trasmissione}}
\\\\Ingressi:
\begin{itemize}
    \item DBIN: dato da trasmettere, formato parallelo;
    \item WR: segnale di write che dà il via alle operazioni per la trasmissione del dato sul canale.
\end{itemize}
Uscite:
\begin{itemize}
    \item TXD: dati trasmessi in formato seriale;
    \item TBE: indica lo stato del buffer di trasmissione: quando è vuoto è pari a 1, 0 altrimenti.
\end{itemize}
\vspace{0.5cm}
{\large \textbf{Ricezione}}
\\\\Ingressi:
\begin{itemize}
    \item RXD: dati in formato seriale in ingresso;
    \item RD: segnale di strobe, ovvero di confermata lettura del dato ricevuto;
    \item RDA: indica la disponibilità di nuovi dati.
\end{itemize}
Uscite:
\begin{itemize}
    \item DBOUT: dato ricevuto, formato parallelo;
    \item RDA: indica la disponibilità di nuovi dati in ingresso;
    \item PE: parity error;
    \item OE: Overrun error;
    \item FE: Farming error.
\end{itemize}
Entrambe le unità, inoltre, presentano un ingresso per il clock ed uno per il segnale di reset.
\clearpage
\subsection{Parte 1}
Tale esercizio richiedeva una trasmissione di 1 carattere da 8 bit tra 2 sistemi A e B, utilizzando il componente standard UART fornito dalla Digilent.
\\Si sono implementati 2 componenti, A e B, progettati tramite approccio strutturale ma composti unicamente dal componente UART, dato che la stringa da trasferire viene passata dall’esterno, così come i segnali di write e reset.
\begin{figure}[ht]
    \centering
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Enove entity_sistemaA.png}
    \caption{Codice Sistema A}
\end{figure}
\begin{figure}[ht]
    \centering
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Enove entity_sistemaB.png}
    \caption{Codice Sistema B}
\end{figure}
\newpage
Il sistema complessivo comprende inoltre 2 debouncer, utilizzati per ripulire i bottoni per i segnali di write e reset.
\\Si è deciso di realizzare 2 entità e di non utilizzare direttamente i componenti UART per poterle riutilizzare nell’esercizio 9.2.
\clearpage
{\large \textbf{Sintesi su FPGA}}
\\\\Per la sintesi su board, così come richiesto dalla traccia, sono stati utilizzati gli switch per definire la stringa di input al sistema A e dei led per visualizzare la stringa riconosciuta dal sistema B.
\begin{figure}[ht]
    \centering
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Enove sintesi9.1.jpg}
    \caption{Sintesi su FPGA Es. 9.1}
\end{figure}
\clearpage
\subsection{Parte 2}
L’esercizio è stato impostato sulla falsa riga dell’esercizio 7, dato che la richiesta di leggere un valore in memoria e trasferirlo era analoga.
\\La differenza sta nel fatto che il protocollo di trasmissione non è parallelo, ma seriale ed è implementato dall’UART. Cosi come fatto però nell’esercizio 7, viene implementato anche un protocollo di handshaking per la comunicazione tra i due sistemi, al fine di evitare errori di overrun dei dati.
\subsubsection{Sistema A}
Il sistema A è stato realizzato attraverso un approccio strutturale partendo dall’entita sviluppata nell’esercizio 9.1, e comprende:
\begin{itemize}
    \item Control unit: ha il compito di effettuare l’handshaking con il sistema B, inviare il segnale di read alla memoria e contemporaneamente quello di write all’UART, per definire la trasmissione. La control unit ha inoltre il compito di effettuare una ritrasmissione nel caso in cui il sistema B notifichi un errore in ricezione.
    \item Contatore: per scandire il termine della trasmissione ed i valori da trasmettere.
    \item ROM: contenente i valori da trasferire.
    \item Delay block: per applicare un delay ai segnali quando necessario.
    \item UART: responsabile della trasmissione dei dati sul canale.
\end{itemize}
\begin{figure}[ht!]
    \centering
    \includesvg[width=\textwidth,height=\textheight]{\Enove sistemaA.svg}
    \caption{Schema Sistema A Es. 9.2}
\end{figure}
\clearpage
\paragraph{Unità Operativa A}
{\large \textbf{Componente Contatore:}}
\begin{figure}[ht]
    \centering
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Enove entity_counter.png}
    \caption{Entity Contatore}
\end{figure}
\\E' stato realizzato tramite approccio comportamentale e l’incremento è definito dal segnale di ab\_counter:
\begin{figure}[ht]
    \centering
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Enove architecture_counter.png}
    \caption{Architecture Contatore}
\end{figure}
\\{\large \textbf{Componente ROM:}}
\\Tale componente è analogo a quello utilizzato nei progetti precedenti e pertanto non viene riportata nuovamente la sua implementazione.
\clearpage
\paragraph{Unità di Controllo A}
{\large \textbf{Control Unit A:}}
\begin{figure}[ht]
    \centering
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Enove entity_controlunita.png}
    \caption{Entity Control Unit A Es. 9.2}
\end{figure}
\\La control unit è definita come una macchina a stati, dove alcune uscite sono associate direttamente agli stati, mentre altre sono associate alla transizione tra stati in base agli ingressi:
\begin{enumerate}
    \item q\_start $\rightarrow$ tale stato è quello in cui si trova la macchina prima di iniziare la trasmissione. La macchina permane in tale stato finché non vede alzarsi il segnale di reset (essendo uscita di un debouncer durerà solo 1 colpo di clock) che viene interpretato come segnale per partire con la trasmissione. A questo punto la macchina passa nello stato q\_trasmett.
    \item q\_trasmett $\rightarrow$ in questo stato la control unit verifica che il segnale di ris in uscita dal sistema B sia basso, ovvero che il sistema non stia elaborando un dato precedentemente inviato. Nel caso in cui il dato trasmesso sia il primo, tale segnale sarà sempre basso; questo controllo è necessario per i dati successivi al primo. Se il segnale di ris viene visto basso, allora il sistema alza il segnale di r e passa nello stato q0, altrimenti permane nello stato q\_trasmett.
    \item q0 $\rightarrow$ tale stato è uno stato di transizione per completare l’handshaking, prima di iniziare la trasmissione vera e propria del dato. Alzando il segnale di r, il sistema A ha espresso la sua intenzione nel trasmettere dei dati, avendo visto che il sistema B è disponibile a ricevere ed elaborarli, ma non ha ancora saputo da esso se effettivamente è pronto a ricevere tali dati o è occupato in operazioni con priorità maggiore. Pertanto, il sistema A rimane nello stato q0 finché non vede alzarsi il segnale di ris da parte del sistema B, sintomo che quest’ultimo è pronto per elaborare i dati trasmessi. Quando ciò accade, si passa nello stato q1 e si abbassa il segnale di r.
    \item q1 $\rightarrow$ arrivati in questo stato vuol dire che può iniziare la vera e propria trasmissione dei dati. Per questo motivo, a tale stato è associata l’uscita write = ‘1’, che viene passata alla memoria ROM come un segnale di read per emettere il dato, e viene inoltre passata con delay di un periodo di clock all’UART, per segnalare la possibilità di trasmettere i dati in ingresso. Il motivo del colpo di delay è dato dal tempo che la memoria impiega per leggere il dato e porlo in uscita. Si passa a questo punto nello stato q2.
    \item q2 $\rightarrow$ allo stato q2 è associata l’uscita write =’0’, dato che tale segnale deve durare 1 colpo di clock per evitare ulteriori letture non richieste alla memoria. Il fatto che il segnale di write però si abbassi, non vuol dire che la trasmissione sia effettivamente iniziata. Per questo motivo si effettua un controllo su TBE, ovvero il segnale in uscita dall’uart che, quando è 0 indica che il canale è occupato e dunque la trasmissione è iniziata, altrimenti inidica un canale ancora libero.
          A questo punto, quando il valore di TBE è diventato 0, si passa nello stato q3, altrimenti si permane in q2.
    \item q3 $\rightarrow$ è lo stato in cui avviene il controllo dell’errore. Finchè ris è alto, ovvero il sistema B sta ancora elaborando i dati, si permane nello stato q3, altrimenti si valuta il segnale di error in entrata dal sistema B. Se il segnale di errore è pari ad 1, non si incrementa ab\_counter e dunque verrà ritrasmesso lo stesso dato, altrimenti il contatore viene incrementato e si procede alla trasmissione del dato successivo se ce ne sono di nuovi. Indistintamente si passa poi nello stato q4.
    \item q4 $\rightarrow$ in tale stato semplicemente si valuta il valore del div del contatore. Se questo è pari a 1, si ritorna nello stato di start e si attende un nuovo segnale di reset per trasmettere nuovi dati, altrimenti si ripassa nello stato q0 e si attende che il segnale di ris da parte del sistema B si abbassi per procedere ad un nuovo handshaking ed una nuova trasmissione.
          Si noti inoltre che a tale stato è associata l’uscita ab\_counter=’0’. Il segnale di ab\_counter serve a dare il segnale di conteggio al contatore e dunque trasmettere il dato seguente, cosa che avviene se il dato è stato ricevuto correttamente dal sistema B e viene abbassato poiché deve durare un colpo di clock per evitare conteggi spuri.
\end{enumerate}
\begin{figure}[ht!]
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Enove architecture_controlunita1.png}
\end{figure}
\clearpage
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.55\textwidth,height=\textheight,keepaspectratio]{\Enove architecture_controlunita2.png}
\end{figure}
\begin{figure}[ht!]
    \includegraphics[width=0.7\textwidth,height=\textheight,keepaspectratio]{\Enove architecture_controlunita3.png}
    \caption{Architecture Control Unit A Es. 9.2}
\end{figure}
\clearpage
{\large \textbf{Considerazioni finali:}}
\\La control unit ha come particolarità quella di lavorare sul fronte di discesa del clock, ovvero in opposizione rispetto a tutti i componenti a cui fornisce dei segnali, in modo che questi li vedano quando sono assestati e non durante la fase di transizione.
\\Il sistema di rilevamento dell’errore e ritrasmissione, implementata tramite il segnale di error, potrebbe andare in loop infinito se gli errori persistono e non vengono risolti con una semplice ritrasmissione. Per evitare ciò andrebbe elaborato un sistema di correzione oltre che uno di ritrasmissione.
\subsubsection{Sistema B}
Il sistema B è stato realizzato attraverso un approccio strutturale partendo dall’entita sviluppata nell’esercizio 9.1, e comprende:
\begin{itemize}
    \item Control Unit: per coordinare i dispositivi ed effettuare l’handshaking con il sistema A;
    \item UART: responsabile della ricezione dei dati da un canale seriale e del loro posizionamento in parallelo in uscita;
    \item Contatore: per fornire l’indice della prima cella di memoria disponibile per salvare il dato ricevuto;
    \item Memoria: per contenere i dati ricevuti.
\end{itemize}
Siccome i dati salvati non vengono riportati in uscita, è stato introdotto un debouncer interno per il segnale di read dato dall’esterno tramite un bottone, in modo che ad ogni segnale si scorra di una posizione la memoria e viene riportato in uscita il valore corrispondente.
\clearpage
\begin{figure}[ht!]
    \centering
    \includesvg[width=1.2\textwidth,height=\textheight]{\Enove sistemaB.svg}
    \caption{Schema Sistema B Es. 9.2}
\end{figure}
\paragraph{Unità Operativa B}
Il componente contatore è analogo a quello utilizzato per il sistema A, mentre il componente ROM è analogo a quello presentato nei progetti precedenti; pertanto non verrà riproposta la loro implementazione.
\clearpage
\paragraph{Unità di Controllo B}
{\large \textbf{Componente Control Unit B:}}
\begin{figure}[ht]
    \centering
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Enove entity_controlunitb.png}
    \caption{Entity Control Unit B Es. 9.2}
\end{figure}
\\La Control Unit è stata realizzata come una macchina a stati, dove alcune uscite sono associate direttamente agli stati, altre alle transizioni in funzione degli ingressi:
\begin{enumerate}
    \item q\_start $\rightarrow$ tale stato è quello in cui permane la macchina prima di rilevare un valore di r alto da parte del sistemaA, segno di richiesta di iniziare una nuova trasmissione. Quando viene rilevato tale segnale, si passa nello stato q0 e si pone alto il segnale di ris.
    \item q0 $\rightarrow$ si permane in questo stato finchè la ricezione dei dati da parte dell’UART non è terminata e quest’ultimi sono presenti nel buffer di uscita. Per capire quando effettivamente ciò avviene, si sfrutta il segnale RDA in uscita dall’UART il quale, quando è pari a 1, indica la presenza dei dati nel buffer. Quando tale segnale viene visto alto quindi, si alza il segnale di RD, che viene dato come strobe per la lettura, e si effettua un controllo sui valori di PE ed FE in uscita dall’UART. Se uno dei due è alto vuol dire che c’è stato un errore nella trasmissione e dunque viene alzato il segnale di error, ma non quello di write, ovvero viene notificato l’errore ad A ed il valore letto non viene salvato in memoria.
          Nel caso di ricezione corretta, invece, viene alzato il segnale di write ed abbassato il segnale di error, il quale che poteva essere alto nella trasmissione precedente. Non abbiamo necessità che il segnale di error duri 1 colpo di clock, ma solo che il suo valore venga aggiornato prima che si abbassi il segnale di ris, poiché è solo in quel momento che tale valore verrà letto dal sistema A.
          Da qui, si passa nello stato q1.
    \item q1 $\rightarrow$  a tale stato è associata l’uscita write =’0’, poiché si vuole che tale segnale rimanga alto solo un colpo di clock per evitare conteggi spuri, dato che tale segnale viene dato come abilitazione al contatore. Viene inoltre abbassato il segnale di RD, il quale sostanzialmente comunica all’UART che il dato posto in uscita è stato letto. Così come definito dal protocollo di handshaking implementato nell’esercizio 7 e riutilizzato per questo progetto, si attende che il segnale di r sia basso prima di abbassare il segnale di ris e passare nello stato q\_start.
\end{enumerate}
\clearpage
\begin{figure}[ht!]
    \includegraphics[width=0.65\textwidth,height=\textheight,keepaspectratio]{\Enove architecture_controlunitb1.png}
\end{figure}
\begin{figure}[ht!]
    \includegraphics[width=0.65\textwidth,height=\textheight,keepaspectratio]{\Enove architecture_controlunitb2.png}
    \caption{Architecture Control Unit B Es.9.2}
\end{figure}
Così come fatto per la Control Unit A, anche questa Control Unit è impostata sul fronte di discesa del clock, per far si che le unità controllate vedano i segnali stabili e non sulle trasizioni.
\clearpage
{\large \textbf{Sintesi su FPGA}}
\\\\A causa dell’alto tempo di simulazione e del numero di segnali da visualizzare, si è ritenuto poco opportuno riportare esempi di simulazione (la quale può essere mandata in esecuzione tramite il file del progetto) e si presenterà unicamente il funzionamento sull’fpga.
\\\\l led V11 (sulla sinistra) corrisponde al segnale di div del contatore del sistema A e rappresenta la fine della trasmissione.
\begin{figure}[ht!]
    \centering
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Enove sintesi9.2.jpg}
    \caption{Sintesi su FPGA Es. 9.2}
\end{figure}
\clearpage
\section{Esercizio 10 - Switch Multistadio}
Progettare ed implementare in VHDL uno switch multistadio secondo il modello omega network. Lo switch progettato deve operare come segue: 
\begin{enumerate}[label=\alph*.]
    \item Lo switch deve consentire lo scambio di messaggi di 2 bit ciascuno da un nodo sorgente a un nodo destinazione in un rete con 4 nodi, implementando uno schema a priorità fissa fra i nodi (ed. nodo 1 più prioritario, con priorità decrescenti fino al nodo 4).
    \item (Opzionale) rimuovendo l’ipotesi di lavorare secondo uno schema a priorità fra i nodi e considerando una rete di 8 nodi, lo switch deve gestire eventuali conflitti generati da collisioni secondo un meccanismo a scelta (ad es. perdendo uno dei messaggi in conflitto).
    \item (Opzionale) Si implementi un protocollo di handshaking semplice regolato da una coppia di segnali (pronto a inviare/pronto a ricevere) per l’invio di ciascun messaggio fra due nodi.
\end{enumerate}
\subsection{Approccio utilizzato}
Per la realizzazione dello switch multistadio utilizzando il modello omega network, è stato utilizzata un’architettura composta da una parte operativa ed una parte di controllo. Il numero di nodi sia in ingresso che in uscita è 4 e la priorità è fissa. Si suppone che, per iniziare la comunicazione, ci sia un segnale di START in ingresso al sistema e che ogni nodo invii un segnale di ENABLE in ingresso per abilitare la comunicazione. Inoltre, si presuppone che possa avvenire una sola comunicazione in base alla priorità, quindi, se lo switch è occupato ad instradare un messaggio, allora eventuali altri pacchetti in arrivo andranno perduti. 
\\Si suppone che il pacchetto dati da inviare da una sorgente allo switch sia composto da 2 bit dato e 2 bit indirizzo destinazione, mentre l’uscita dello switch è composto dai soli 2 bit dato.
\clearpage
\subsection{Parte Operativa}
La parte operativa realizza il modello di Omega Network su 4 nodi sorgente e 4 nodi destinazione, è stata realizzata con un approccio strutturale, utilizzando come componenti elementari dei blocchi di instradamento. Questi non sono altro che la composizione di un Mux 2:1 e di un Demux 1:2 : per il primo l’indirizzo di selezione è quello sorgente, mentre per il secondo è quello destinazione. Tale componente è stato realizzato con un approccio Dataflow.
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.6\textwidth,height=\textheight,keepaspectratio]{\Edieci blocco_instradamento.PNG}
    \caption{Blocco instradamento}
\end{figure}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.6\textwidth,height=\textheight,keepaspectratio]{\Edieci blocco_instradamento_vhdl.PNG}
    \caption{Blocco instradamento VHDL}
\end{figure}
\clearpage
Sfruttando l’approccio strutturale, si collegano i componenti elementari in accordo con il perfect shuffling. Secondo questa tecnica, avendo M carte, dopo un numero di iterazioni del mescolamento perfetto pari a log2 M si riottiene l’ordinamento di partenza; analogamente, per connettere completamente M nodi serviranno log2 M stadi. Nel nostro caso abbiamo 4 nodi da connettere, quindi 2 stadi con 2 switch ciascuno. Le stringhe contenenti gli indirizzi sono lunghe 2 bit, in quanto i nodi destinazione sono 4 e, avendo assunto che la comunicazione si verifichi da sinistra verso destra, i bit di destinazione vanno dati ai vari stadi (uno per ciascuno) a partire dal bit più significativo. I bit di sorgente, invece, vanno dati dal bit meno significativo al più significativo.
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.55\textwidth,height=\textheight,keepaspectratio]{\Edieci interfaccia_operative_unit.PNG}
    \caption{Entity Unità Operativa}
\end{figure}
\\Il generic N permette di scegliere il numero di bit dato trasmessi nella comunicazione all’interno dell’Omega Network.
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.95\textwidth,height=\textheight,keepaspectratio]{\Edieci unitaoperativa.PNG}
    \caption{Unità Operativa}
\end{figure}
\newpage
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.7\textwidth,height=\textheight,keepaspectratio]{\Edieci operative_unit_vhdl_1.PNG}
\end{figure}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.65\textwidth,height=\textheight,keepaspectratio]{\Edieci operative_unit_vhdl_2.PNG}
    \caption{Architecture Unità Operativa}
\end{figure}
\clearpage
\subsection{Parte di Controllo}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.6\textwidth,height=\textheight,keepaspectratio]{\Edieci interfaccia_control_unit.PNG}
    \caption{Interfaccia Unità di Controllo}
\end{figure}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=1.2\textwidth,height=\textheight,keepaspectratio]{\Edieci unita_controllo.PNG}
    \caption{Unità di Controllo}
\end{figure}
\newpage
La parte di controllo è realizzata con un approccio strutturale ed ha come componenti: MUX 4:1, DEMUX 1:4, Encoder 4:2 e Buffer; i primi 3 componenti sono stati realizzati utilizzando un approccio Dataflow. La parte di controllo ha il compito di stabilire la priorità tra i nodi. Questa riceve in ingresso il pacchetto per ogni linea, 4 segnali di ENABLE provenienti dai rispettivi 4 nodi sorgente ed il segnale di START. In uscita produce il pacchetto composto da 2 bit dato, 2 bit indirizzo sorgente e 2 bit indirizzo destinazione.
\\A partire dai segnali di ENABLE, l’encoder produce in uscita la codifica della linea abilitata in ingresso, dando al nodo 0 la priorità massima, mentre al nodo 3 la priorità minima. Una volta trovato l’indirizzo sorgente si abilitano le linee dato relative ad esso tramite il MUX 4:1: i primi due bit sono relativi all’indirizzo destinazione, mentre i restanti sono di tipo dato. Quest’ultimi attraversano, poi, il DEMUX per avere lo stesso parallelismo dell’Omega network. Il compito del demultiplexer è dunque quello di dare in ingresso all’omega network un vettore di 8 bit: tale vettore presenterà tutti bit pari a 0, fatta eccezione per i 2 bit riferiti al nodo con priorità maggiore tra quelli che hanno richiesto la trasmissione.
\\I dati, l’indirizzo destinazione e sorgente vengono poi inseriti all’interno di un buffer che li memorizza temporaneamente, ad ogni comunicazione, per poterli inserire all’interno dell’Omega Network.
\\\\{\large \textbf{MUX 4:1}}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.6\textwidth,height=\textheight,keepaspectratio]{\Edieci mux41vhdl.PNG}
    \caption{MUX 4:1}
\end{figure}
\clearpage
{\large \textbf{DEMUX 4:1}}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.7\textwidth,height=\textheight,keepaspectratio]{\Edieci demux41vhdl.PNG}
    \caption{DEMUX 4:1}
\end{figure}
\\\\{\large \textbf{Encoder}}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.6\textwidth,height=\textheight,keepaspectratio]{\Edieci encodervhdl.PNG}
    \caption{Encoder}
\end{figure}
\clearpage
{\large \textbf{Buffer}}
\begin{figure}[ht!]
    \includegraphics[width=0.5\textwidth,height=\textheight,keepaspectratio]{\Edieci buffervhdl1.PNG}
\end{figure}
\begin{figure}[ht!]
    \includegraphics[width=0.7\textwidth,height=\textheight,keepaspectratio]{\Edieci buffervhdl2.PNG}
    \caption{Buffer}
\end{figure}
\newpage
Il buffer è stato realizzato con un approccio Behavioral, cioè come una macchina a stati che ad ogni segnale di start effettua il refresh del pacchetto memorizzato:
\begin{itemize}
    \item qinit $\rightarrow$ Stato iniziale in cui si aspetta un nuovo segnale di start. Appena arriva tale segnale si effettua il reset del buffer e si passa allo stato q1.
    \item q1 $\rightarrow$ Stato in cui avviene l’acquisizione del nuovo pacchetto, ed al colpo di clock successivo si sposta in qinit, mantenendo memorizzato il pacchetto corrente.
\end{itemize}
L’architettura Structural complessiva dell’unità di controllo è mostrata in figura:
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.7\textwidth,height=\textheight,keepaspectratio]{\Edieci architetturacontrolunit1.PNG}    
\end{figure}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.6\textwidth,height=\textheight,keepaspectratio]{\Edieci architetturacontrolunit2.PNG}    
    \caption{Architecture Unità di Controllo}
\end{figure}
\clearpage
\subsection{Simulazione}
Per effettuare la simulazione, nel testbench abbiamo utilizzato un sistema con periodo di clock pari a 10ns. Vengono inserite nel sistema i segnali di ENABLE e DATA\_IN per rappresentare la volontà di comunicazione dei nodi sorgente. Si suppone che il segnale di start si alzi per un solo periodo di clock.
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.9\textwidth,height=\textheight,keepaspectratio]{\Edieci testbemchvhdl.PNG}    
    \caption{Testbench}
\end{figure}
\newpage
\begin{figure}[ht]
    \centering
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Edieci simulazione.png}    
    \caption{Simulazione}
\end{figure}
Dalla simulazione si ottiene che ponendo tutti i bit di ENABLE alti, solo la prima linea riesce a comunicare perché è quella a priorità più alta. Questa comunica con la linea 2 di uscita il dato 2. Essendo tutti i blocchi dell’Omega Network combinatori, la presentazione del risultato in simulazione è istantanea ed avviene non appena è caricato il Buffer con il pacchetto. Nella realtà vi è la presenza di ritardi dovuti alle porte combinatorie.
\clearpage
\subsection{Considerazioni finali}
Il sistema è funzionante solo per una comunicazione alla volta, secondo una priorità fissa. In realtà sarebbe possibile effettuare anche più comunicazioni all’interno dell’Omega Network, a patto di gestire le collisioni tra nodi sorgente che vogliono comunicare con una stessa destinazione e tra nodi sorgente che comunicano con diverse destinazioni, ma durante il percorso per raggiungere i nodi destinatari attraversano nodi intermedi comuni. 
\\Una possibile soluzione per poter gestire tali collisioni prevede di complicare il blocco di instradamento con una coda ed un’interfaccia che permettano di memorizzare i dati in arrivo sulle due linee di ingresso. È necessario, inoltre, realizzare un protocollo di handshaking asincrono (aumentando il numero di linee) tra il blocco trasmettitore ed il blocco ricevente per ogni linea d’ingresso, in modo da stabilire quando il blocco trasmettitore è pronto ad inviare e quando il blocco ricevente è pronto ad acquisire su ogni linea dato. 
\\Ad ogni ciclo di trasmissione da uno stadio al successivo, il blocco in presenza di collisioni ritarda, tramite la coda, la trasmissione di uno dei pacchetti ricevuto in base ad una priorità. In questo modo si realizza un’architettura sincrona rispetto al clock e quindi aumenta il ritardo di trasmissione dal nodo sorgente a quello destinazione per via della gestione dell’handshaking.
\\Inoltre, bisogna gestire le comunicazioni concorrenti in ingresso al sistema switch, in particolare se più nodi inviano pacchetti allo stesso switch è necessario che quest’ultimo li acquisisca evitandone la perdita. Una possibile soluzione sarebbe quella di adottare un sistema di handshaking asincrono tra i vari nodi e lo switch.

\newpage
\section{Esercizio 11 - Divisore Restoring}
\subsection{Introduzione}
L’obiettivo di questo esercizio è quello di progettare, tramite un approccio strutturale, un divisore che ci permetta di effettuare una divisione tra un dividendo espresso su M bit ed un divisore, espresso su N bit. Il risultato sarà composto da un resto, codificato su al più N bit, ed un quoziente, espresso al più su M-N+1 bit (supponendo che il primo degli $m \over{n}$ bit non sia nullo).
\\Analizziamo ora il procedimento di divisione, per comprendere quali sono i componenti da utilizzare:
\begin{itemize}
    \item Passo iniziale: si confrontano gli n bit più significativi del dividendo (dividendo parziale) con gli n bit del divisore: se il divisore è contenuto nel dividendo parziale, allora il quoziente parziale (qi) sarà pari ad 1, 0 altrimenti (Il risultato delle operazioni di divisione parziale può essere al massimo 1, quindi in binario si ha un grande vantaggio).
          Si effettua quindi la sottrazione tra il dividendo parziale ed il prodotto $q_i \cdot V$ (dove V rappresenta il divisore), ottenendo così il primo resto parziale.
    \item Generico passo i: si pone il dividendo parziale $D_i$ pari al resto parziale $R_i$ (calcolato all’iterazione i-1) e si confronta con il divisore. A questo punto i passaggi successivi sono analoghi a quelli riportati al passo 1, con l’unica differenza che il resto parziale andrà riportato con uno shift a destra di i posizioni.
\end{itemize}
La formula generale per calcolare i resti parziali al passo i+1 è dunque:
\begin{center}
    \vspace{5mm}$R_{i+1} = R_i -q_i \cdot V \cdot 2^{(-i)}$ \vspace{5mm}
\end{center}
Mantenendo questo procedimento avremmo dunque bisogno di uno shift register con shift variabile, in modo da poter effettuare uno shift diverso ad ogni passo.
\\Si è tuttavia ricavato un algoritmo alternativo, al fine di effettuare uno shift di una sola posizione ad ogni iterazione: invece di effettuare uno shift del resto parziale i+1 al termine delle operazioni, si effettua (ad ogni iterazione) uno shift a sinistra del dividendo parziale $R_i$ e, con tale valore che in binario coincide a $2R_i$, si calcola $R_{i+1}$.
\\L’algoritmo alternativo è del tutto equivalente a quello standard, con l’unica differenza che richiede uno shift di un’unica posizione ad ogni iterazione, a differenza del precedente, dove lo shift variava in base al passo i.
\\Valutiamo ora il numero di registri necessari per effettuare completamente le operazioni: il registro A, in cui immettiamo il dividendo, ad ogni iterazione viene svuotato di 1 bit (a causa degli shift verso sinistra dei dividendi parziali), mentre, il registro Q (contenente il quoziente) si riempie di 1 bit. Si può utilizzare quindi un unico registro AQ, il quale, al termine delle operazioni conterrà il resto negli N bit più significativi e nei restanti M-N+1 bit il quoziente.
\\Utilizzando tale algoritmo però, il registro AQ dovrà presentare la prima cella vuota, in modo da effettuare lo shift anche al primo passo senza perdere alcun bit.
\\Come visto dalla procedura manuale, l’operazione di divisione richiede una successione di sottrazioni e confronti; l’operazione di comparazione, idealmente, potrebbe essere effettuata mediante un componente comparatore. Tuttavia, anziché definire un nuovo componente, l’operazione di comparazione viene effettuata mediante un sottrattore, valutando il bit più significativo del risultato. Supponiamo infatti di voler effettuare un confronto tra A e B: effettuando l’operazione A-B, se il risultato presenta il bit più significativo, che chiameremo S per comodità, pari ad 1 (ovvero il risultato è negativo in una rappresentazione in complemento a 2), allora $A<B$, altrimenti $A>=B$.
\\Utilizzando questo metodo, possiamo sfruttare il sottrattore per effettuare anche la comparazione, il che porta un ulteriore vantaggio: siccome la comparazione avviene tra $2R_i$ e V, il risultato ci fornisce anche il valore di $R_i+1$, nel caso in cui $2R_i > V$. Nel caso in cui, invece, $2R_i < V$ va effettuata un’operazione di ripristino del valore di $R_{i+1}$, riportandolo pari a $R_i$.
\\Per gestire tale rispristino ci sono 2 algoritmi possibili:
\begin{itemize}
    \item Restoring: effettua il ripristino sempre al passo i-esimo; se il risultato della sottrazione da esito negativo, nello stesso passo si somma nuovamente V al valore di $R_{i+1}$, in modo da ottenere nuovamente il valore di Ri.
    \item Not restoring: effettua una correzione al passo i+1; tramite manipolazioni algebriche si è visto che, se al passo i+1 effettuo una somma al posto di una sottrazione, ottengo lo stesso risultato del restoring.
\end{itemize}
Dato che entrambe le tecniche prevedono sia l’addizione che la sottrazione, avremo bisogno di un componente che implementa entrambe operazioni.
\\È bene notare che, a differenza dei moltiplicatori, i divisori sono implementati unicamente con un approccio sequenziale, dato che il risultato al passo i-esimo dipende dal risultato del passo i-1, non permettendo quindi un’implementazione di tipo parallelo.
\\Come tutte le macchine complesse, il divisore restoring è composto da una parte operativa ed una di controllo.
\begin{figure}[ht]
    \centering
    \includesvg[width=\textwidth,height=\textheight]{\Eundici divisore.svg}
    \caption{Schema Divisore Es. 11}
\end{figure}
\subsection{Unità Operativa}
La parte operativa è stata progettata tramite un approccio strutturale, ed è composta da:
\begin{itemize}
    \item Registro AQ: registro che inizialmente contiene il dividendo e che, al termine delle operazioni, conterrà il quoziente ed il resto.
    \item Registro V: registro che contiene il divisore.
    \item Sommatore RippleCarry: sommatore/sottrattore.
    \item Contatore: necessario ad indicare il termine delle operazioni da svolgere.
\end{itemize}
\clearpage
{\large \textbf{Componente Registro AQ:}}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Eundici e_regAQ.png}
    \caption{Entity Registro AQ}
\end{figure}
\vspace*{1cm}
\\E' stato progettato tramite un approccio comportamentale, dato che ci sono più segnali di controllo da gestire.
\\Implicitamente, con tale implementazione, è stato definita anche una priorità tra i segnali in ingresso, anche se ha poca rilevanza dato che, tali segnali, non saranno mai alti contemporaneamente (fa eccezione il solo segnale di reset, il quale potrebbe alzarsi in qualsiasi momento poiché proveniente dall’esterno e non dall’unità di controllo).
\\La dimensione ti tale registro è pari a 2N, dato che sia il resto che il quoziente saranno codificati su N bit.
\clearpage
\begin{figure}[ht!]
    \centering
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Eundici b_regAQ.png}
    \caption{Architecture Registro AQ}
\end{figure}
{\large \textbf{Componente Registro V:}}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.7\textwidth,height=\textheight,keepaspectratio]{\Eundici e_regV.png}
    \caption{Entity Registro V}
\end{figure}
\\Così come il registroAQ, anche tale registro è stato implementato mediante un approccio di tipo comportamentale.
\clearpage
\begin{figure}[ht!]
    \centering
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Eundici b_regV.png}
    \caption{Architecture Registro V}
\end{figure}
{\large \textbf{Componente Contatore:}}
\\Tale componente è analogo a quello presentato nell’esercizio 9; pertanto non verrà riportata nuovamente la sua implementazione.
\\\\{\large \textbf{Componente Adder-Subtracter:}}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Eundici e_add.png}
    \caption{Entity Adder-Subtracter}
\end{figure}
\clearpage
Le operazioni necessarie per la divisione richiedono sia operazioni di somma che di differenza; pertanto, la scelta è ricaduta su un unico componente in grado di effettuare entrambe le operazioni. È stato progettato tramite un approccio strutturale, utilizzando un Ripple carry adder ed un signal che effettua il complemento a 2 di uno degli ingressi.
\begin{figure}[ht!]
    \centering
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Eundici b_add.png}
    \caption{Architecture Adder-Subtracter}
\end{figure}
\vspace*{2cm}
\\{\large \textbf{Component Ripple Carry Adder:}}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Eundici e_ripple.png}
    \caption{Entity Ripple Carry Adder}
\end{figure}
\clearpage
Nonostante dal punto di vista prestazionale tale componente non sia tra i più efficienti, la scelta è ricaduta comunque su di esso data la sua struttura semplice e ritardi comunque trascurabili per operandi a 4 bit. È stato realizzato mediante interconnessione di componenti full-adder:
\begin{figure}[ht!]
    \centering
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Eundici b_ripple.png}
    \caption{Architecture Ripple Carry Adder}
\end{figure}
\\\\{\large \textbf{Componente Full-Adder:}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.9\textwidth,height=\textheight,keepaspectratio]{\Eundici e_full.png}
    \caption{Entity Full-Adder}
\end{figure}
\clearpage
E' il componente base che ci permette di effettuare la somma su 2 bit ed è stato progettato mediante approccio Dataflow:
\begin{figure}[ht!]
    \centering
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Eundici d_full.png}
    \caption{Architecture Full-Adder}
\end{figure}
\subsection{Unità di Controllo }
Al termine di tale panoramica sui componenti presenti nell’unità operativa, passiamo ora allo studio dell’unità di controllo.
\\{\large \textbf{Control Unit}}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Eundici e_cu.png}
    \caption{Entity Control Unit}
\end{figure}
\clearpage
\begin{figure}[ht!]
    \centering
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Eundici schema_cu.png}
    \caption{Schema Control Unit}
\end{figure}
L’unità di controllo è stata realizzata come una macchina a stati:
\begin{enumerate}
    \item q\_start $\rightarrow$ In tale stato si attende il segnale di reset. Quando arriva, si passa in q0;
    \item q0 $\rightarrow$ In tale stato si attende il segnale di start. Quando questo arriva si passa nello stato shift1;
    \item Shift1$\rightarrow$ A tale stato sono associate le uscite en\_load =0 e subtract=1. Queste servono a modificare le uscite dello stato di load: en load perché deve essere alto 1 colpo di clock, subtract perché di base la prima operazione che facciamo svolgere all’adder è la sottrazione per il confronto, poi se necessario viene effettuata l’addizione per il restore.
          Si effettua poi un controllo sul valore di stop, corrispondente all’uscita div del contatore: se questa è alta, ovvero abbiamo effettuato tutte le operazioni, non si effettua un nuovo shift ma si ritorna nello stato di start e ci si pone in attesa di un reset. Se invece il valore del div è basso, si passa allo stato di shift2 e si alza il segnale di shift, per abilitare lo scorrimento del registro AQ, e si alza il segnale di abilitazione per il conteggio del contatore;
    \item Shift2$\rightarrow$ In tale stato semplicemente si abbassano i segnali alzati nella transizione, poiché vogliamo siano alti solo 1 colpo di clock per evitare conteggi o shift spuri. A questo punto si passa allo stato di wait;
    \item Wait $\rightarrow$ In tale stato si attende semplicemente che il sommatore abbia effettuato il confronto. Siccome è una macchina puramente combinatoria e non ha nessun segnale di abilitazione, il sommatore darà sempre un valore in uscita; sta a noi aspettare il tempo necessario, per far si che il risultato sia relativo agli operandi immessi e non ai precedenti. Il sommatore ha il suo ritardo dovuto alla propagazione, per questo è necessario tale stato. Con operandi a 4 bit, questo stato intermedio è sufficiente a garantire che il risultato in uscita sia quello corretto; tuttavia, all’aumentare del numero di bit, potrebbe essere necessario aggiungere un nuovo stato di attesa oppure abbassare la frequenza del clock. Si passa poi allo stato di check;
    \item Check $\rightarrow$ In tale stato si effettua il controllo sul confronto avvenuto tramite sottrazione:
          \begin{itemize}
              \item Se il bit più significativo è basso, ovvero il risultato è positivo, si passa allo stato di write e non è necessario il restore. Si pone, inoltre, il valore del quoziente parziale pari a 1;
              \item Se il bit più significativo è alto, ovvero il risultato è negativo, si passa allo stato di restore.
                    Si pone, inoltre, il valore del quoziente parziale pari a 0 e si alza il segnale di wr\_aq, al fine di scrivere il valore in uscita dal sommatore nel registro aq per effettuare il restore.
          \end{itemize}
    \item Restore $\rightarrow$ In tale stato si abbassa il valore di subtract, poiché è necessario fare la somma per effettuare il restore, e si abbassa inoltre il segnale di wr\_aq, per evitare sovrascritture indesiderate. Si passa poi allo stato di complete restore;
    \item Complete Restore$\rightarrow$ Tale stato ha sostanzialmente lo stesso scopo dello stato di wait, ovvero dare il tempo all’adder di effettuare il restore e prendere il risultato corretto. Si passa poi allo stato di write;
    \item Write $\rightarrow$ Tale stato scrive l’uscita Z dell’adder nella parte del registro AQ dedicata ad A, che ovviamente sarà diversa in base a se viene effettuato il restore o meno: nel primo caso il valore scritto coinciderà con il precedente, altrimenti sarà pari al valore della differenza calcolata. Si alza quindi il segnale di wr\_aq e si passa nello stato di load;
    \item Load $\rightarrow$ In tale stato si abbassa il segnale di wr\_aq e si alza quello di en\_load, per caricare nella parte dedicata a Q il bit del risultato parziale. Si ritorna poi nello stato di shift1.
\end{enumerate}
\clearpage
\begin{figure}[ht!]
    \centering
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Eundici b_cu1.png}
\end{figure}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.7\textwidth,height=\textheight,keepaspectratio]{\Eundici b_cu2.png}
\end{figure}
\begin{figure}[ht!]
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Eundici b_cu3.png}
    \caption{Architecture Control Unit}
\end{figure}
\clearpage
\subsection{Simulazione e Sintesi}
\begin{figure}[ht!]
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Eundici sim1.png}
\end{figure}
\begin{figure}[ht!]
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Eundici sim2.png}
    \caption{Simulazione Sistema Es. 11}
\end{figure}
{\large \textbf{Implementazione su fpga:}}
\\Per l’implementazione su scheda sono stati introdotti 2 debouncer per i segnali di start e reset ed il componente display, necessario per la visualizzazione dei risultati.
\\Il problema principale del passaggio da simulazione ad fpga, per un progetto di questo tipo, riguarda la frequenza del clock: quest’ultimo potrebbe essere troppo veloce e non dare il tempo all’adder di svolgere le operazioni e di fornire il risultato corretto. Nel nostro caso, dato che gli operandi sono su soli 4 bit, non è stato necessario introdurre un divisore di frequenza; all’aumentare però della dimensione degli operandi, potrebbe tuttavia essere necessario introdurlo.
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.8\textwidth,height=\textheight,keepaspectratio]{\Eundici e_sis.png}
\end{figure}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.8\textwidth,height=\textheight,keepaspectratio]{\Eundici s_sis1.png}
\end{figure}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.9\textwidth,height=\textheight,keepaspectratio]{\Eundici s_sis2.png}
    \caption{Sistema Complessivo Es. 11}
\end{figure}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.7\textwidth,height=\textheight,keepaspectratio]{\Eundici fpga.jpg}
    \caption{FPGA Es. 11}
\end{figure}
\clearpage
\section{Esercizio 12 - Interfaccia VGA}

\newpage
\listoffigures
\end{document}