\documentclass[12pt]{article}

\usepackage{graphicx,caption,svg}
\usepackage[utf8]{inputenc}

\renewcommand{\contentsname}{Indice}
\setlength{\parindent}{0pt}

\def \Euno {Allegati/Esercizio1/}
\def \Edue {Allegati/Esercizio2/}
\def \Etre {Allegati/Esercizio3/}
\def \Equattro {Allegati/Esercizio4/}
\def \Ecinque {Allegati/Esercizio5/}
\def \Esei {Allegati/Esercizio6/}
\def \Esette {Allegati/Esercizio7/}
\def \Eotto {Allegati/Esercizio8/}
\def \Enove {Allegati/Esercizio9/}
\def \Edieci {Allegati/Esercizio10/}
\def \Eundici{Allegati/Esercizio11/}
\def \Edodici {Allegati/Esercizio12/}


\begin{document}

\title{Tesina Architettura dei Sistemi Digitali}
\date{\today}
\tableofcontents
\newpage
\section{Esercizio 1 - Multiplexer}
\subsection{Parte 1}
L’esercizio 1.1 richiede la rappresentazione di un multiplexer 16:1 tramite la composizione di multiplexer 4:1, quindi definiamo il module del componente mux\_4\_1 definito in modo Dataflow, e poi per le proprietà della modularità definiamo il module mux\_16\_1 come composizione dei precedenti, tramite il costrutto \textit{for..generate}.


Il multiplexer 4:1 ha come ingressi quattro bit, identificati col vettore a(0 to 3), e $\lceil \log_{2}(n) \rceil$ segnali di abilitazione, dove n è il numero di segnali di ingresso. In questo caso, quindi, due segnali di abilitazione ed uno di uscita.
\begin{figure}[ht]
    \centering
    \includesvg[width=\textwidth,height=0.2\textheight]{\Euno mux_4_1.svg}
    \caption{Mux 4:1}
\end{figure}

Il codice in VHDL per descrivere il comportamento di questo componente è il seguente:
\begin{figure}[ht]
    \centering
    \includegraphics[width=\textwidth,height=0.3\textheight,keepaspectratio]{\Euno mux_4_1_dataflow.png}
    \caption{Mux 4:1 Dataflow}
\end{figure}

Composto da un costrutto \textit{when...else} che suddivide i diversi casi e gestisce anche tutti i casi non definiti con l’ultima clausola else senza alcuna condizione.

Definito l’elemento base del progetto, si passa a comporre il multiplexer 16:1 tramite un approccio strutturale, nel quale generiamo cinque mux\_4\_1: i primi quattro avranno gli ingressi interfacciati con l’esterno e, tramite segnali interni, le loro uscite sono collegate come ingressi dell’ultimo multiplexer che costituisce  l’uscita del sistema.
La macchina completa presenta quindi 16 segnali di ingresso, 4 segnali di selezione ed un unico segnale di uscita:

\begin{figure}[ht]
    \centering
    \includesvg[width=\textwidth,height=0.65\textheight]{\Euno mux_16_1.svg}
    \caption{Mux 16:1}
\end{figure}
\newpage
Lo schema sopra rappresentato è tradotto in linguaggio VHDL dal seguente codice, dove l’entità mux\_16\_1 è rappresentata con approccio strutturale e, tramite i segnali interni c(0 to 3), colleghiamo le uscite parziali dei primi quattro mux\_4\_1, identificati con la label mux\_4\_1\_in, con i quattro ingressi dell’ultimo mux\_4\_1, identificato con la label mux\_4\_1\_fin.
\begin{figure}[ht]
    \centering
    \includegraphics[width=1.3\textwidth,height=0.6\textheight,keepaspectratio]{\Euno mux_16_4_structural.png}
    \caption{Mux 16:1 Dataflow}
\end{figure}
\newpage
Progettato il mux\_16\_1, è possibile testarlo attraverso un testbench. La prima cosa che bisogna specificare è che il corpo dell’entity è vuoto, questo perché non si tratta di oggetto che realizziamo, ma serve solo per effettuare la simulazione e verificare se il sistema realizzato funziona correttamente. Il testbench effettivamente non ha né segnali d’ingresso né d’uscita, ma sfrutta per i test i segnali interni definiti nel codice. Per testare il mux\_16\_1 definito precedentemente, abbiamo istanziato una uut (Unit
Under Test) in cui colleghiamo le varie porte ai segnali (input, selection, output).\newline
\begin{figure}[h]
    \centering
    \includegraphics[width=1.2\textwidth,height=0.6\textheight,keepaspectratio]{\Euno mux_16_1_tb.png}
    \caption{Mux 16:1 Testbench}
\end{figure}
\newpage Dopo aver effettuato queste assegnazioni, compreso di costrutto after per permettere l’evoluzione del sistema durante il tempo, si passa alla schermata di simulazione nella quale si può analizzare e studiare l’evoluzione nel tempo di ogni segnale presente nel codice, compresi eventuali segnali intermedi.
\begin{figure}[ht]
    \centering
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Euno mux_16_1_simulazione.png}
    \caption{Mux 16:1 Simulazione}
\end{figure}
\newline Possiamo analizzare l’evoluzione del programma:
dopo circa 150ns, l’ingresso è posto a “0000000000000001” e contemporaneamente la selezione è posta a “1111”, ottenendo come uscita del sistema “1”. Questo è effettivamente il comportamento atteso.
\newpage


\subsection{Parte 2}
L’esercizio 1.2 è in parte riconducibile all’esercizio precedente, in quanto la rappresentazione di una rete 16:4 può essere scomposta da una sottorete 16:1 connessa ad un demux 1:4. Basta quindi aggiungere un demultiplexer 1:4 alla rete precedente. Il demux 1:4 è realizzato con approccio Dataflow.
\begin{figure}[ht]
    \centering
    \includegraphics[width=0.8\textwidth,height=\textheight,keepaspectratio]{\Euno demux_4_1_dataflow.png}
    \caption{Demux 1:4 Dataflow}
\end{figure}
\newline Il Demux 1:4 presenta come uscita un segnale di 4 bit, di cui 3 pari a zero ed uno pari al valore in ingresso, la cui posizione è determinata a seconda dei segnali di abilitazione.
\begin{figure}[ht]
    \centering
    \includesvg[width=\textwidth,height=0.4\textheight]{\Euno rete_16_4.svg}
    \caption{Rete 16:1}
\end{figure}
\newpage
Una volta eseguite le interconnessioni tramite un unico segnale interno, utilizzato per collegare l’uscita del mux\_16\_1 con l’ingresso del demux\_1\_4, si ottiene la rete 16:4:  tale rete presenta 16 segnali di ingressi totali, 6 di selezione (di cui 2 utilizzati per il demux) e 4 segnali di uscita.
\begin{figure}[ht]
    \centering
    \includegraphics[width=0.8\textwidth,height=\textheight,keepaspectratio]{\Euno rete_16_4_structural.png}
    \caption{Rete 16:4 Structural}
\end{figure}
\\
Anche dopo aver testato il singolo componente, è comunque necessario ripetere il test per la macchina completa, sia perché potrebbero essere presenti errori e problemi derivanti da implementazione di nuove funzioni, sia perché anche nella composizione di una macchina più complessa sono presenti intrinsecamente problemi legati alla coesione dei vari moduli.
\newpage
\begin{figure}[ht]
    \centering
    \includegraphics[width=0.4\textwidth,height=\textheight,keepaspectratio]{\Euno rete_16_4_tb.png}
    \caption{Rete 16:4 Testbench}
\end{figure}

\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.7\textwidth,height=\textheight,keepaspectratio]{\Euno rete_16_4_simulazione.png}
    \caption{Rete 16:4 Simulazione}
\end{figure}
\newpage

\subsection{Parte 3}
Come esercizio finale, è stato necessario adattare la rete per la sintesi sulla FPGA. Attraverso l’utilizzo di un file di constraint ideato per la board Nexys A7-50t, possiamo definire i collegamenti da effettuare sulla scheda tra le diverse periferiche disponibili e le componenti presenti all’interno della rete.
\newline
In questo caso sono necessari 6 switch per le linee di abilitazione dei multiplexer e demultiplexer. Poichè gli switch sono in totale 16, è stato necessario dare un input predefinito alla rete ed utilizzare gli switch unicamente per la selezione.
Inoltre, sempre dal file di costraint, sono stati abilitati anche 4 led e connessi ai quattro bit di uscita, come indicato nel seguente file.
\begin{figure}[ht]
    \centering
    \includegraphics[width=0.7\textwidth,height=\textheight,keepaspectratio]{\Euno costraints_es1.png}
    \caption{Costraints}
\end{figure}
\\Quindi, gli switch \textbf{\textit{J15-L16-M13-R15}} sono stati mappati ai quattro bit di selezione dei multiplexer, mentre gli switch \textbf{\textit{R17-T18}} ai due bit di selezione dei multiplexer, ed, infine, i led H17-K15-J13-N14 come rappresentazione visiva dei quattro bit di uscita al sistema complessivo.
\newline
Il sistema finale è quello raffigurato nella seguente figura
\begin{figure}[ht]
    \centering
    \includegraphics[width=0.8\textwidth,height=\textheight,keepaspectratio]{\Euno rete_16_4_analysis.png}
    \caption{Rete 16:4 Analysis}
\end{figure}


\newpage
\section{Esercizio 2 - Encoder BCD}
\subsection{Traccia}

Progettare, implementare in VHDL e testare mediante simulazione una rete che, data in ingresso una stringa binaria X di 10 bit X9 X8 X7 X6 X5 X4 X3 X2 X1 X0 che corrisponde alla rappresentazione decodificata di una cifra decimale (cioè, una rappresentazione in cui ogni stringa contiene un solo bit alto), fornisce in uscita la rappresentazione Y della cifra mediante codifica Binary-Coded Decimali (BCD).
\\Input: 0000000001 $\Rightarrow$ Output: 0000 (cifra 0)
\\Input: 0000000010 $\Rightarrow$ Output: 0001 (cifra 1)
\\Input: 0000000100 $\Rightarrow$ Output: 0010 (cifra 2)
\\....
\\Sintetizzare ed implementare su board il progetto dell’encoder BCD utilizzando gli switch per fornire la stringa X in ingresso, e i led per visualizzare Y. Nel caso in cui si utilizzi una board dotata di soli 8 switch, è possibile sviluppare il progetto considerando X di soli 8 bit (la macchina sarà allora in grado di fornire in uscita la rappresentazione BCD delle cifre decimali da 0 a 7).
\\Utilizzare un display a 7 segmenti per visualizzare la cifra decimale codificata da Y (pilotare opportunamente i catodi del display per visualizzare la cifra).
\subsection{Soluzione}
La rete è stata realizzata con vari componenti secondo un approccio strutturale. Essa ha un ingresso, cioè il valore della stringa X da 10 bit, e 2 uscite, utili per visualizzare la cifra codificata su un display a 7 segmenti.
La rete utilizza i seguenti componenti:
\begin{itemize}
    \item Un encoder: a sua volta composto da un arbitro a priorità e da un encoder 10:4;
    \item Un display manager per la visualizzazione dell’output;
\end{itemize}
Si è partiti, dunque, da una descrizione dataflow dei componenti base, per poi procedere con una descrizione strutturale dell’encoder ed una descrizione comportamentale del display manager. Infine, mettendo insieme questi ultimi 2 componenti, si è descritto l’intero sistema, chiaramente a livello strutturale.

    {\large  \textbf{Arbitro a priorità:}}
\\Il componente relativo all’arbitro di priorità dispone di un vettore di ingresso di 10 bit e di un vettore di uscita di altrettanti bit, in cui l’uscita avrà tutti 0 e un solo bit alto nella prima posizione in cui è stato trovato un 1 (a partire dalla posizione più significativa).
\\\\{\large \textbf{Encoder 10:4:}}
\\Il componente relativo all’encoder 10:4 presenta in ingresso un vettore di 10 bit ed in uscita un vettore di 4 bit, che rappresenta il numero in binario della prima posizione con bit alto in ingresso (valore compreso nel range [0,9]).
\\\\Facendo uso dei due componenti appena descritti, si è realizzato un encoder, il quale facendo uso di un segnale interno che fa da interconnessione tra l’uscita dell’arbitro e l’ingresso dell’encoder 10:4, prende in ingresso un vettore di 10 bit e restituisce in uscita un vettore di 4 bit effettuando la codifica Binary-Coded Decimal (BCD).
\\\\{\large \textbf{Display Manager:}}
\\Il componente display manager prende in ingresso un vettore di 4 bit e lo rappresenta sul display a 7 segmenti con 2 uscite. Al suo interno vengono definite delle costanti su 7 bit relative ai segmenti di una cifra del display da illuminare, in questo modo si visualizza un determinato valore in esadecimale. La prima uscita è fissa, al fine di illuminare costantemente solo la prima cifra del display, poiché il valore da mostrare è rappresentabile con una sola cifra. La seconda uscita determina i segmenti della cifra da illuminare, pertanto dipende dall’ingresso.
\\La rete complessiva dispone dell’encoder e del display manager. Il vettore di ingresso di 10 bit andrà nell’encoder e la sua uscita su 4 bit, mediante un segnale di interconnessione, andrà in ingresso al display manager che mostra il valore di uscita sul display.
\newpage
\subsection{Codice}
{\large \textbf{Arbitro}}
\\L’architettura è stata descritta a livello dataflow e, scorrendo un vettore a partire dalla posizione 9 fino a 0, se tra i 10 bit uno solo è alto, l’uscità sarà una stringa con tutti 0 e solo un bit alto nella posizione in cui lo era nel vettore di ingresso. Nel caso in cui il vettore di ingresso presenta più bit uguali a 1, la stringa in uscita avrà il solo bit alto nella prima posizione, partendo dalla 9, in cui trova un 1.
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.7\textwidth,height=\textheight,keepaspectratio]{\Edue codice_arbitro.jpg}
    \caption{Codice Arbitro}
\end{figure}
\newpage
{\large \textbf{Encoder 10:4}}

L’encoder 10:4 è stato descritto a livello dataflow. L’architettura, partendo da un vettore con solo un bit alto, restituisce in uscita il valore su 4 bit della posizione in cui il bit è alto.
\begin{figure}[ht]
    \centering
    \includegraphics[width=0.6\textwidth,height=\textheight,keepaspectratio]{\Edue codice_encoder10_4.jpg}
    \caption{Codice Encoder 10:4}
\end{figure}
\newpage
{\large \textbf{Encoder complessivo}}
\\L’encoder complessivo è descritto a livello strutturale utilizzando i componenti “arbitro” e “encoder10\_4”. All’interno del sistema è definito un segnale t di tipo std\_logic\_vector(9 downto 0), che fa da interconnessione e viene utilizzato come uscita dell’arbitro e come ingresso dell’encoder 10:4.
\begin{figure}[ht]
    \centering
    \includegraphics[width=0.6\textwidth,height=\textheight,keepaspectratio]{\Edue codice_encoder_parte1.jpg}
\end{figure}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.5\textwidth,height=\textheight,keepaspectratio]{\Edue codice_encoder_parte2.jpg}
    \caption{Codice Encoder Complessivo}
\end{figure}
\newpage
{\large \textbf{Display Manager}}
\begin{figure}[ht]
    \centering
    \includegraphics[width=0.2\textwidth,height=\textheight,keepaspectratio]{\Edue display.jpg}
    \caption{Display Segment}
\end{figure}
\newline
Questo componente viene descritto a livello comportamentale. Viene definita l’entity con una porta in ingresso, value, e due porte in uscita, anode e cathode, tutte di tipo std\_logic\_vector. Nel costrutto architecture sono definite delle costanti di 7 bit, dove la posizione rappresenta un segmento di una cifra del display: quando il bit è 0 il segmento è acceso, altrimenti è spento. Poiché il valore è in notazione esadecimale, sono state definite le costanti che rappresentano i valori da 0 a f. Per tenere accesa solo la prima cifra del display, l’uscita anode viene settata con tutti i bit alti, ad eccezione di quello meno significativo; in questo modo le cifre successive alla prima sono spente. Si usa l’altra uscita, cathode, per rappresentare il valore tramite una AND tra ‘1’ e la costante che rappresenta il valore da mostrare a video.
\begin{figure}[ht]
    \centering
    \includegraphics[width=0.9\textwidth,height=\textheight,keepaspectratio]{\Edue codice_display_manager_parte1.jpg}
\end{figure}
\begin{figure}[ht]
    \centering
    \includegraphics[width=0.8\textwidth,height=\textheight,keepaspectratio]{\Edue codice_display_manager_parte2.jpg}
\end{figure}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.9\textwidth,height=\textheight,keepaspectratio]{\Edue codice_display_manager_parte3.jpg}
    \caption{Codice Display Manager}
\end{figure}
\newpage
{\large \textbf{Sistema Completo}}
\\Nella descrizione strutturale dell’architettura si definiscono i componenti encoder, quello complessivo, e display manager e si definisce un segnale interno temp, di tipo std\_logic\_vector, che fa da interconnessione tra l’uscita dell’encoder e l’ingresso del display manager, al fine di rappresentare a video l’output dell’encoder.
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.5\textwidth,height=\textheight,keepaspectratio]{\Edue codice_sistema_completo_parte1.jpg}
\end{figure}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.5\textwidth,height=\textheight,keepaspectratio]{\Edue codice_sistema_completo_parte2.jpg}
\end{figure}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.4\textwidth,height=\textheight,keepaspectratio]{\Edue codice_sistema_completo_parte3.jpg}
    \caption{Codice Sistema Completo}
\end{figure}
\subsection{Simulazione}
Per effettuare la simulazione è stato utilizzato il seguente testbench per l’encoder:
\begin{figure}[ht]
    \centering
    \includegraphics[width=0.6\textwidth,height=\textheight,keepaspectratio]{\Edue sim1.jpg}
\end{figure}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.6\textwidth,height=\textheight,keepaspectratio]{\Edue sim2.jpg}
    \caption{Codice Testbench}
\end{figure}
\begin{figure}[ht]
    \centering
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Edue simulazione_encoder.jpg}
    \caption{Simulazione Encoder}
\end{figure}
\clearpage
\section{Esercizio 3 - Riconoscitore di Sequenze}
\subsection{Traccia}
Progettare, implementare in VHDL e testare mediante simulazione una macchina in grado di riconoscere la sequenza 1001. La macchina prende in ingresso un segnale binario i che rappresenta il dato, un segnale A di tempificazione e un segnale M di modo, che ne disciplina il funzionamento, e fornisce un’uscita Y alta quando la sequenza viene riconosciuta. In particolare,
\begin{itemize}
    \item se M=0, la macchina valuta i bit seriali in ingresso a gruppi di 4,
    \item se M=1, la macchina valuta i bit seriali in ingresso uno alla volta, tornando allo stato iniziale ogni volta che la sequenza viene correttamente riconosciuta.
\end{itemize}
Sintetizzare e implementare su board la rete sviluppata al punto precedente, utilizzando uno switch S1 per codificare l’input i e uno switch S2 per codificare il modo M, in combinazione con due bottoni B1 e B2 utilizzati rispettivamente per acquisire l’input da S1 e S2 in sincronismo con il segnale di tempificazione A, che deve essere ottenuto a partire dal clock della board. Infine, l’uscita Y può essere codificata utilizzando un led.
\subsection{Soluzione}

La macchina realizzata è un riconoscitore che, in base al modo stabilito, riconosce la sequenza 1001. Pertanto, il riconoscitore viene descritto a livello strutturale e dispone di 3 componenti:
\begin{itemize}
    \item Il debouncer (descritto a livello comportamentale);
    \item Un gestore per il modo (descritto a livello strutturale);
    \item Il sistema che si occupa del riconoscimento vero e proprio (descritto a livello comportamentale).
\end{itemize}
\newpage
{\large \textbf{Sistema per il riconoscimento}}

Il sistema che effettua il riconoscimento viene descritto a livello comportamentale.
\begin{figure}[ht]
    \centering
    \includegraphics[width=0.7\textwidth,height=\textheight,keepaspectratio]{\Etre codice_sistema_parte1.png}
    \caption{Codice Sistema Pt1}
\end{figure}
\\Nella descrizione è definito un tipo enumerativo “status” che contiene tutti i possibili stati della macchina: S0, S1, S2, S3, S4, S5, S6, S7. Per quanto riguarda il modo, nello specifico, se M=1 vengono considerati i primi 5 stati, se M=0 vengono considerati tutti.
Tra questi, lo stato S4 viene raggiunto se la sequenza 1001 è stata riconosciuta.
Il comportamento della macchina è definito da un process sensibile al clock:
Se il segnale di RESET è alto, allora resetta lo stato corrente della macchina, riportandolo a S0, e permette di acquisire il nuovo modo M.
Se M=1,
\begin{itemize}
    \item Stato S0: se si riceve in ingresso 0, si permane in S0; se si riceve 1, si va in S1, poiché è stato riconosciuto un 1 (prima cifra della sequenza cercata);
    \item Stato S1: se si riceve 1, si permane in S1, poiché non è la prossima cifra cercata, ma l’ultima trovata è un 1; se si riceve 0, si va in S2 ed è stata riconosciuta la sequenza 10;
    \item Stato S2: se si riceve 1, si ritorna in S1; se si riceve 0, si va in S3 ed è stata riconosciuta 100;
    \item Stato S3: se si riceve 0, si ritorna in S0, poiché sarebbe stata riconosciuta la sequenza 1000, che non è quella che si ricercava; se si riceve 1, si va in S4 e si riconosce proprio la sequenza 1001.
\end{itemize}
Se M=0, c’è un concetto di conteggio su 4 bit, pertanto anche in caso di valore non ricercato in ingresso, si procede in avanti verso altri stati. Nello specifico,
\begin{itemize}
    \item Stato S0: se si riceve 1, come prima si va in S1; altrimenti si va in S5;
    \item Stato S1: se si riceve 0, si va in S2; altrimenti si va in S6;
    \item Stato S2: se si riceve 0, si va in S3; altrimenti in S7;
    \item Stato S3: se si riceve 1, si va in S4 e la sequenza 1001 è stata riconosciuta; altrimenti si torna in S0 perché su 4 bit è stata riconosciuta la sequenza 1000, che non è quella cercata.
\end{itemize}
Per gli stati successivi non importa il bit ricevuto in ingresso, in quanto a gruppi di 4 bit alla volta non sarebbe riconosciuta la sequenza ricercata, pertanto
\begin{itemize}
    \item Stato S5: va in S6;
    \item Stato S6: va in S7;
    \item Stato S7: va in S0.
\end{itemize}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=\textwidth,height=0.4\textheight,keepaspectratio]{\Etre codice_sistema_parte2.png}
\end{figure}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=\textwidth,height=0.55\textheight,keepaspectratio]{\Etre codice_sistema_parte3.png}
\end{figure}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=\textwidth,height=0.3\textheight,keepaspectratio]{\Etre codice_sistema_parte4.png}
    \caption{Codice Sistema Pt2}
\end{figure}
\clearpage
{\large \textbf{Debouncer}}
\\Tale componente ha il compito di trasformare un segnale rumoroso in un segnale pulito. Quando un segnale arriva da un bottone sarà sicuramente effetto da rumore, come riportato in figura. Ad un occhio umano, tali oscillazioni non vengono percepite ma, quando tale segnale viene analizzato ad un microcontrollore, queste vengono rilevate a pieno e potrebbero creare problemi (se tale segnale va in ingresso ad un contatore si traduce in conteggi spuri).
\begin{figure}[ht!]
    \centering
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Etre debouncer.png}
    \caption{Debouncer}
\end{figure}
Il debouncer viene progettato come una macchina a stati:
\begin{itemize}
    \item Stato not pressed: il sistema permane in questo stato finchè non vede il segnale in ingresso alzarsi. Passa così nello stato pressed.
    \item Stato pressed: il sistema permane in questo stato finchè il segnale in ingresso non si abbassa. Quando ciò accade, si utilizza una variabile di conteggio, la quale fa si che passi un periodo di tempo pari a D2 prima di riportare il segnale come alto in uscita e tornare nello stato not pressed.
\end{itemize}
Il segnale in uscita rimane alto per un periodo di clock dato che, quando il sistema ritorna nello stato not pressed, l’uscita viene abbassata nuovamente. A differenza di un debouncer classico, l’uscita viene riportata alta solo dopo che il segnale si è abbassato e non dopo un tempo D1 dal fronte di salita; la scelta è stata fatta poiché, altrimenti, se il bottone venisse premuto troppo a lungo potrebbe essere rilevato nuovamente ed in uscita si produrrebbero 2 segnali puliti invece di 1.
\newpage
{\large \textbf{Filtro per il modo}}

Questo componente prende in ingresso il segnale filtrato dal debouncer, chiamato “cleared\_button”, il clock e l’input dallo switch S2, che rappresenta il modo, e restituisce il modo. Viene descritto a livello comportamentale:  se il bottone B2 è premuto, il modo viene impostato tramite S2.
\begin{figure}[ht]
    \centering
    \includegraphics[width=0.6\textwidth,height=\textheight,keepaspectratio]{\Etre codice_filtro_modo.jpg}
    \caption{Codice filtro modo}
\end{figure}
\\{\large \textbf{Gestore per il modo}}
\\Il componente relativo alla gestione del modo viene descritto a livello strutturale e si compone di un debouncer e di un filtro per il modo. Prende in ingresso il clock, il segnale del bottone B2, l’input dallo switch S2. B2 va in ingresso al debouncer per la pulizia del segnale e l’uscita del debouncer, attraverso il segnale interno cb\_temp va in ingresso al filtro insieme a S2. L’uscita sarà data dal filtro, pertanto sarà il modo, che successivamente sarà dato in ingresso al sistema di riconoscimento.
\begin{figure}[ht]
    \includegraphics[width=0.5\textwidth,height=\textheight,keepaspectratio]{\Etre codice_gestore_modo_parte1.jpg}
\end{figure}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=1.1\textwidth,height=0.7\textheight]{\Etre codice_gestore_modo_parte2.jpg}
    \caption{Codice gestore modo}
\end{figure}
\clearpage
{\large \textbf {Riconoscitore}}
\\Il riconoscitore complessivo viene descritto in modo Strutturale tramite i componenti presentati finora.
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.8\textwidth,height=\textheight,keepaspectratio]{\Etre codice_riconoscitore_parte1.jpg}
\end{figure}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.8\textwidth,height=\textheight,keepaspectratio]{\Etre codice_riconoscitore_parte2.jpg}
\end{figure}
\clearpage
\begin{figure}[ht!]
    \centering
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Etre codice_riconoscitore_parte3.jpg}
    \caption{Codice riconoscitore}
\end{figure}
{\large \textbf{Simulazione}}
\\Per la simulazione si è usato il seguente testbench sul riconoscitore completo, compreso di sistema di riconoscimento, debouncer e gestore del modo:
\begin{figure}[ht!]
    \centering
    \includegraphics[width=\textwidth,height=0.15\textheight]{\Etre simulazione_riconoscitore.jpg}
    \caption{Simulazione riconoscitore}
\end{figure}
\newpage
\section{Esercizio 4 - Shift Register}
\subsection{Traccia}
{\large \textbf{Shift register}}
\\L’esercizio richiede la progettazione di uno shift register, mediante un approccio sia comportamentale che strutturale, con le seguenti caratteristiche:
\begin{itemize}
    \item Modo variabile: lo shift register, sulla base di un segnale in ingresso, deve effettuare shift verso destra o verso sinistra.
    \item Shift variabile: sulla base di un segnale in ingresso, il registro deve poter variare il numero di posizioni di shift.
\end{itemize}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Equattro entity_shift.png}
    \caption{Entity Shift Bidirezionale}
\end{figure}
\subsection{Approccio comportamentale}
Per la progettazione di tipo comportamentale è stato utilizzato il costrutto \textit{if}, dato che sia le opzioni di modo che di shift comprendevano solo due possibilità; in un caso più generale, il costrutto case sarebbe più appropriato.
Lo shift register realizzato prevede un ingresso seriale ed un output parallelo, gestiti nel seguente modo:
\begin{itemize}
    \item Ingresso mode: tale segnale varia la modalità di shift: se pari ad 1, il valore viene inserito da destra, altrimenti da sinistra.
    \item Ingresso a: tale segnale funge da abilitazione, ovvero il registro effettua uno shift solo se, sul fronte di salita del clock, rileva un’abilitazione pari ad 1.
    \item Ingresso shift: è il segnale che gestisce il numero di posizioni dello shift: quando è pari a 0, avviene lo shift di una posizione, altrimenti di due.
\end{itemize}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.8\textwidth,height=0.8\textheight,keepaspectratio]{\Equattro architecture_shift.png}

\end{figure}

\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.3\textwidth,height=0.3\textheight,keepaspectratio]{\Equattro architecture_shift_2.png}
    \caption{Architecture Shift Register Bidirezionale}
\end{figure}
\clearpage
\subsection{Approccio Strutturale}
Per la realizzazione tramite un approccio strutturale, sono stati realizzati dei flip flop D bidirezionali.
\\\\{\large \textbf{Component Ffd\_bidirezionali:}}
\begin{figure}[ht]
    \centering
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Equattro ffd1.png}
    \caption{Entity Flip Flop D}
\end{figure}
\\La logica di tale componente è molto semplice:
\\prevede 2 ingressi (leftInput e RightInput) e, in base al segnale di mode in ingresso, decide quale riportare in uscita. Tale componente è sincrono e lavora solo con abilitazione pari ad 1.
\clearpage
\begin{figure}[ht]
    \centering
    \includegraphics[width=\textwidth,height=0.7\textheight,keepaspectratio]{\Equattro ffd2.png}
    \caption{Architecture Flip Flop D}
\end{figure}
{\large \textbf{Component mux\_2\_1:}}
\\Tale componente è necessario per selezionare quale valore deve essere riportato in ingresso ai flipflop, in base allo shift richiesto.
Dato che lo shift può variare al massimo di una posizione, un multiplexer 2:1 è sufficiente; in un caso più generale, si potrebbe ricorrere ad un multiplexer con un numero maggiore di ingressi.
\clearpage
\begin{figure}[ht]
    \centering
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Equattro mux.png}
    \caption{Mux 2:1}
\end{figure}
Vediamo ora come tali componenti sono stati combinati:
\clearpage
\begin{figure}[ht!]
    \centering
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Equattro generate1.png}
\end{figure}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Equattro generate2.png}
    \caption{ Generate FFD}
\end{figure}
\begin{itemize}
    \item \textbf{PrimoFF:} è il primo flip flop da sinistra, ovvero quello di posizione 1. È stato differenziato dagli altri poiché presenterà il multiplexer solo sull’ingresso destro, dato che il sinistro è legato all’input del registro.
    \item \textbf{UltimoFF:} è il primo flip flop da destra, ovvero quello di posizione N. È stato differenziato dagli altri poiché presenterà il multiplexer solo sull’ingresso sinistro, dato che il destro è legato all’input del registro.
    \item \textbf{FF\_with0:} sono i flipflop che, nel multiplexer per la selezione, presentano degli 0, in quanto non hanno abbastanza flipflop che li precedono. Es: nel flipflop di posizione 2, per l’ingresso sinistro, la scelta ricadrà tra l’uscita del flipflop di posizione 1 ed uno 0, dato che non esiste un flipflop di posizione 0.
    \item \textbf{FFintermedi:} sono quei flipflop che presentano multiplexer si per l’ingresso di destra che di sinistra, ed entrambi prendono gli ingressi da flipflop precedenti.
\end{itemize}
\clearpage
\begin{figure}[ht!]
    \centering
    \includesvg[width=\textwidth,height=0.9\textheight]{\Equattro esercizio4.svg}
    \caption{Progetto Completo Esercizio 1}
\end{figure}
\subsection{Simulazione}
Verrà ora presentata una simulazione del funzionamento della macchina, verificando tutte le combinazioni dei segnali mode e shift. I risultati della simulazione sono analoghi per entrambe le architecture.
\begin{figure}[ht]
    \centering
    \includegraphics[width=1\textwidth,height=0.4\textheight]{\Equattro sim.png}
    \caption{Simulazione Shift Register}
\end{figure}
\newpage
\section{Esercizio 5 - Cronometro}
\subsection{Traccia}
{\large \textbf{Cronometro}}
\\L’obiettivo di questo esercizio è quello di progettare un cronometro tramite un approccio strutturale, visualizzando i valori di ore, minuti e secondi sul display presente sulla board.
Il progetto prevede sicuramente l’utilizzo di una serie di contatori, i quali dovranno scandire il tempo.
\\{\large \textbf{Contatore:}}
\begin{figure}[ht]
    \centering
    \includegraphics[width=\textwidth,height=0.2\textheight]{\Ecinque entity_contatore.png}
    \caption{Entity Contatore}
\end{figure}
\\Tale contatore è stato implementato tramite un approccio comportamentale, in modo da incrementare il valore di conteggio solo in presenza di un opportuno segnale di abilitazione.
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.6\textwidth,height=0.3\textheight,keepaspectratio]{\Ecinque architecture_contatore.png}
    \caption{Architecture Contatore}
\end{figure}
\\Data la richiesta di poter settare i valori di secondi, minuti e ore da cui il cronometro deve partire, si è deciso di introdurre due ingressi aggiuntivi: un segnale di set ed un vettore d’ingresso.
Sostanzialmente, quando il segnale di set è alto, il contatore non rileva il segnale di abilitazione e carica il valore presente in ingresso; quando il segnale di set si abbassa, il contatore ritorna al suo normale funzionamento.
Una volta definiti tre contatori differenti per scandire ore, minuti e secondi, vediamo come questi sono stati combinati tra loro.
\\\\{\large \textbf{Sistema Contatori:}}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Ecinque entity_sistema_c.png}
    \caption{Entity Sistema Contatori}
\end{figure}
\\E’ formato da 4 contatori, 1 blocco di delay ed un blocco AND. Il primo contatore che ritroviamo è un divisore di frequenza, il quale ha il compito di passare dalla frequenza del clock della board a quella di 1HZ, la cui uscita di div funge da abilitazione per  il contatore dei secondi.
L’uscita di div del contatore  dei secondi entra, poi, come abilitazione del contatore relativo ai minuti; entrambi i contatori sono definiti modulo 60.
Leggermente più complessa è la connessione con il contatore relativo alle ore, il quale dovrà effettuare un conteggio quando sia il contatore dei secondi che quello dei minuti sono arrivati al termine. Come segnale di abilitazione, dunque, si utilizza l’uscita di una porta and, che presenta come ingresso entrambi i segnali di div dei contatori precedenti.
Si presenta però un problema di tempificazione: il segnale di div del contatore relativo ai secondi, fungendo da abilitazione al contatore dei minuti e rimanendo alto per 1 solo colpo di clock, si alzerebbe appunto un colpo di clock prima di quello dei minuti; si è realizzato pertanto un blocco di delay, il quale ritarda tale segnale di 1 colpo di clock, in modo che la porta AND possa vedere entrambi i segnali alti. Se non avessimo usato tale blocco, il contatore delle ore non avrebbe mai visto il segnale di abilitazione alto.
\begin{figure}[ht]
    \centering
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Ecinque architecture_sistema_c.png}
\end{figure}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=\textwidth,height=0.4\textheight]{\Ecinque struct.png}
    \caption{Struct Sistema Contatori}
\end{figure}
\clearpage
{\large \textbf{Component wait\_block:}}
\\E' stato progettato mediante un approccio comportamentale, con lo scopo di ritardare di 1 colpo di clock il segnale in ingresso.
\begin{figure}[ht!]
    \centering
    \includegraphics[width=\textwidth,height=0.4\textheight,keepaspectratio]{\Ecinque wait_block.png}
    \caption{Wait Block}
\end{figure}
\\{\large \textbf{Schema sistema contatori}}
\begin{figure}[ht!]
    \centering
    \includesvg[width=\textwidth,height=\textheight]{\Ecinque sistema_contatori.svg}
\end{figure}
\\Definita la parte relativa al conteggio, possiamo ora vedere i componenti necessari al set di un valore iniziale dei contatori, in modo da far partire il cronometro da un orario scelto.
\\\\{\large \textbf{Component gestore\_set:}}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=\textwidth,height=0.4\textheight,keepaspectratio]{\Ecinque gestore_set.png}
    \caption{Gestore set}
\end{figure}
\\Il segnale di set in ingresso ai contatori viene processato da un gestore di set, il quale ha il compito di mantenere quel segnale sempre alto finché non vengono settate ore, minuti e secondi.
Il segnale di set viene prodotto dal gestore\_set in base ad un segnale fornito dall’esterno tramite un pulsante: la prima volta che si riceve tale segnale, il valore di set viene posto ad 1.
A questo punto, tutti i contatori fermano il conteggio e rimangono in attesa di un vettore in ingresso e, tramite una variabile di conteggio chiamata count, si gestisce quale contatore inizializzare ad ogni passo.
Il vettore in ingresso, infatti, contiene solo 6 bit e viene ogni volta aggiornato con il valore di ore, minuti e secondi che si vuole caricare; si è preferita una scelta di questo tipo rispetto ad un unico vettore contenente 17 ingressi dato che, quando si passerà alla sintesi su fpga, non saranno presenti 17 switch per gli input.
Tornando alla variabile count, vediamo come il componente gestisce gli ingressi:
\begin{itemize}
    \item Count=1 : i valori in ingresso vengono caricati nel counter dei secondi;
    \item Count=2 : i valori in ingresso vengono caricati nel counter dei minuti;
    \item Count=3 : i valori in ingresso vengono caricati nel counter delle ore;
\end{itemize}
Quando il count arriva a 3, inoltre, il suo valore viene portato a 0, indicando la fine dei dati in input da ricevere.
Il valore di count viene incrementato ogni volta che arriva il segnale esterno che definisce il set; la quarta volta che il gestore riceve tale segnale, il valore di count sarà pari a 0 e, dunque, il segnale di set in uscita verrà abbassato e il cronometro riprende il suo normale funzionamento.
È bene notare che, tutte le operazioni del gestore\_set vengono eseguite quando il segnale di ingresso ab\_modo è pari a 0; il motivo verrà spiegato nel seguito.
\begin{figure}[ht!]
    \centering
    \includegraphics[width=\textwidth,height=0.3\textheight,keepaspectratio]{\Ecinque set1.png}
\end{figure}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=\textwidth,height=0.3\textheight,keepaspectratio]{\Ecinque set2.png}
    \caption{Architecture Gestore set}
\end{figure}
\clearpage
L’implementazione riportata è già adattata alla sintesi su fpga, introducendo dei valori di output relativi all’accensione di alcuni led, i quali indicano quale counter stiamo inizializzando.

\subsection{Sintesi su fpga}
Così come richiesto nell’esercizio 5.2, il componente cronometro realizzato in precedenza verrà sintetizzato su fpga. In particolare, verrà utilizzato il display a 7 segmenti presente sulla board, per la visualizzazione dell’orario, e 2 bottoni, per inviare i segnali di set e reset.
Tuttavia, tale sintesi non può essere immediata, ma  necessita di 2 componenti aggiuntivi:
\begin{itemize}
    \item Debouncer: componente che serve a ripulire il segnale inviato dal bottone, che sarà sicuramente caratterizzato da rumore.
    \item Convertitore per display: l’uscita dei contatori deve essere tradotta in un formato leggibile dal display.
\end{itemize}
{\large \textbf{Componente debouncer:}}
\\Tale componente ha il compito di trasformare un segnale rumoroso in un segnale pulito e la sua implementazione è analoga a quella riportata nell’esercizio 3.
\\\\\\{\large \textbf{Componente conv\_per\_display:}}
\\Tale componente è stato progettato con un approccio dataflow: prende in ingresso i vettori in uscita dai contatori e traduce ognuno di essi in 2 vettori da 4 bit (richiesti dal display in ingresso), i quali rappresentano i valori di decine e unità.
\clearpage
\begin{figure}[ht]
    \centering
    \includegraphics[width=\textwidth,height=0.6\textheight,keepaspectratio]{\Ecinque conv.png}
    \caption{Convertitore per display}
\end{figure}
Le uscite di questo componente andranno poi in ingresso al display\_manager.
\newline\newline\textbf{Estensione con intertempi:}
\\Per far si che il sistema sia in grado di memorizzare degli intertempi, sono stati aggiunti ulteriori componenti:
\begin{itemize}
    \item Gestore modo: necessario per la visualizzazione degli intertempi salvati.
    \item Memoria: componente nel quale salvare gli intertempi.
\end{itemize}
{\large \textbf{Componente Gestore\_modo:}}
\begin{figure}[ht]
    \centering
    \includegraphics[width=\textwidth,height=0.3\textheight,keepaspectratio]{\Ecinque modo1.png}
    \caption{Entity Gestore modo}
\end{figure}
\clearpage
E' stato realizzato come una macchina a 2 stati
\begin{itemize}
    \item Stato cronometro: a tale stato è associata l’uscita ab\_modo=0, la quale indica che l’uscita sul display è quella del sistema dei contatori, ovvero stiamo visualizzando il cronometro che scorre. Quando riceve in ingresso il segnale di cambio modo, inviato da un pulsante e gestito da un debouncer, si passa allo stato intertempo.
    \item Stato intertempo: a tale stato è associata l’uscita ab\_modo=1, la quale indica dunque che l’uscita sul display è quella della memoria, ovvero stiamo visualizzando gli intertempi salvati.
\end{itemize}
Per implementare la modalità intertempi, dunque, le uscite dei contatori e della memoria entrano nel gestore modo il quale, in base alla modalità di funzionamento del sistema, decide quale dei due ingressi riportare in uscita. Tale uscita andrà poi in ingresso al convertitore per display.
L’uscita ab\_modo verrà inoltre riportata in ingresso alla memoria ed al gestore set, in quanto ne limita le funzionalità:
\begin{itemize}
    \item Gestore set: quando siamo nella modalità intertempo, non è possibile settare un valore nei contatori.
    \item Memoria: quando si è nella modalità cronometro e si invia un segnale di write, allora l’intertempo viene scritto in memoria, altrimenti no. Inoltre, i dati possono essere letti dalla memoria e riportati sullo schermo, in corrispondenza di un segnale di read, solo quando il sistema è in modalità intertempo.
\end{itemize}
È bene notare che il segnale di ab\_modo non va in ingresso al sistema di contatori. Si è infatti supposto che, anche quando si è in modalità intertempo, il cronometro continua a lavorare, ma il tempo non viene mostrato sul display. Quando si ripassa alla modalità cronometro, infatti, si noterà che il valore di conteggio sarà avanzato.
\begin{figure}[ht!]
    \includegraphics[width=\textwidth,height=0.7\textheight,keepaspectratio]{\Ecinque modo2.png}
\end{figure}
\begin{figure}[ht!]
    \includegraphics[width=\textwidth,height=0.1\textheight,keepaspectratio]{\Ecinque modo3.png}
    \caption{Architecture Gestore modo}
\end{figure}
\clearpage
{\large \textbf{Componente memoria:}}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=\textwidth,height=0.5\textheight,keepaspectratio]{\Ecinque memoria.png}
    \caption{Entity Memoria}
\end{figure}
\\Tale componente è stato progettato tramite un approccio comportamentale e varia le sua funzionalità in base alla modalità di lavoro del sistema:
\begin{itemize}
    \item Modalità intertempo: permette, in corrispondenza di un segnale di read, di scorrere gli intertempi salvati. Non si possono salvare nuovi intertempi in tale modalità.
    \item Modalità cronometro: permette, in corrispondenza di un segnale di write, di salvare l’intertempo in memoria. Non si possono visualizzare gli intertempi salvati in tale modalità.
\end{itemize}
Per come è stata progettata, se si salvano più di N intertempi, vengono sovrascritti i primi che sono stati salvati.
\begin{figure}[ht!]
    \centering
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Ecinque memoriab.png}
    \caption{Architecture Memoria}
\end{figure}
\begin{figure}[ht!]
    \centering
    \includesvg[width=\textwidth,height=\textheight]{\Ecinque esercizio5.svg}
    \caption{Schema Completo Esercizio 5}
\end{figure}
\clearpage
\section{Esercizio 6 - Sistema di Testing}
\subsection{Traccia}
\textbf{Esercizio 6.1:} Progettare, implementare in VHDL e verificare mediante simulazione un sistema in grado di testare in maniera automatica una macchina combinatoria M avente 4 ingressi e 3 uscite binarie sottoponendole N ingressi diversi (si considerino una macchina M e un numero di input N a scelta dello studente).
Gli N valori di input per il test devono essere letti da una ROM, in cui essi sono precaricati, in corrispondenza di un segnale read. Le N uscite fornite della macchina in corrispondenza di ciascuno degli input devono essere memorizzati in una memoria interna, che deve poter essere svuotata in qualsiasi momento in presenza di un segnale di reset.
\\\\\textbf{Esercizio 6.2:} Sintetizzare ed implementare su board il componente sviluppato al punto precedente, utilizzando due bottoni per i segnali di read e reset rispettivamente e i led per la visualizzazione delle uscite della macchina istante per istante.
\subsection{Implementazione}
{\large \textbf{Scelte progettuali:}}
\\L’esercizio richiedeva di progettare un sistema di testing per una macchina combinatoria, a partire da dei valori di input per la macchina precaricati in una ROM, si visualizza l’output della macchina combinatoria a tali valori tramite dei LED. Gli output vengono visualizzati a intervalli di 1s. Per poter iniziare il testing della macchina occorre un segnale di RESET, necessario per svuotare la memoria, ed un segnale di READ, per presentare in ingresso alla macchina gli input presenti nella ROM.
\begin{figure}[ht!]
    \centering
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Esei sistema_esterno.jpg}
\end{figure}
\clearpage
Il sistema è stato progettato mediante un approccio strutturale:
\begin{figure}[ht!]
    \centering
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Esei sistema_comp.jpg}
    \caption{Sistema Complessivo}
\end{figure}
\\\\{\large \textbf{Tester:}}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Esei tester.jpg}
    \caption{Tester}
\end{figure}
\clearpage
Il tester è anch’esso realizzato con approccio strutturale. Lo scopo di questo componente è quello di presentare in uscita dei valori da dare in input alla macchina che si vuole testare ed inviare un segnale di scrittura per il salvataggio dei risultati.Il sistema è composto da:
\\\\{\large \textbf{Gestore read:}}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.55\textwidth,height=0.55\textheight,keepaspectratio]{\Esei gestore_read_entity.png}
\end{figure}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.55\textwidth,height=0.55\textheight,keepaspectratio]{\Esei gestore_read_archit.png}
    \caption{Gestore Read}
\end{figure}
\clearpage
A partire dal segnale ripulito di READ viene prodotto un segnale di OUT\_READ  che rimane alto per tanti periodi di clk quanti sono gli input di test: $N \cdot Tclk$. E’ realizzato come una macchina a stati:
\begin{itemize}
    \item Stato NOTREAD: in tale state il valore di out\_read è pari a 0 e rimane in attesa di un segnale cleared\_read, appena questo arriva si passa nello stato di READ.
    \item Stato READ: a tale stato è associata l’uscita out\_read pari a 1; il sistema rimane in questo stato per N colpi di clock per poi tornare allo stato NOTREAD.
\end{itemize}
{\large \textbf{ROM:}}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.9\textwidth,height=\textheight,keepaspectratio]{\Esei rom_entity.png}
\end{figure}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.9\textwidth,height=\textheight,keepaspectratio]{\Esei rom_process.png}
    \caption{ROM}
\end{figure}
\clearpage
E’ stata realizzata come una memoria precaricata, che all’arrivo del segnale di read visualizza in uscita il valore puntato ed incrementa il puntatore ai valori memorizzati. Il generic permette di memorizzare i valori al variare della variabile N.
\\{\large \textbf{DELAY:}}
\\Il blocco di delay è necessario per poter ritardare il segnale di write in memoria, in questo modo si sincronizza l’uscita della macchina combinatoria al segnale di scrittura. Si suppone che la macchina combinatoria abbia un ritardo inferiore al $Tclock\over{2}$; se così non fosse allora dovremmo aumentare il periodo del clock con un divisore in frequenza.
\begin{figure}[ht!]
    \centering
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Esei delay_block.png}
    \caption{Delay Block}
\end{figure}
\\Il blocco di delay e la ROM agiscono sul fronte di discesa del clock in modo che il ritardo ottenuto sia tale da campionare il valore di uscita della macchina quando è stabile e non sulla transizione. Il segnale di write, infatti, varia sul fronte di discesa del clock, mentre la scrittura in memoria avviene sul fronte di salita.
\\\\Memoria: è realizzata in maniera comportamentale. La scrittura avviene con la delay\_write (che dura $N \cdot Tclk$), quindi permette di scrivere N valori in uscita dalla macchina combinatoria. La lettura avviene con la read\_gestore (che dura Tclk), la quale permette di scorrere i valori in memoria con periodo di 1s. Agiscono due puntatori: uno per la lettura ed uno per la scrittura.
\begin{figure}[ht!]
    \centering
    \includegraphics[width=\textwidth,height=0.7\textheight,keepaspectratio]{\Esei memoria_esterna.png}
    \caption{Memoria Esterna}
\end{figure}
\\{\large \textbf{Gestore Led:}}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.7\textwidth,height=\textheight,keepaspectratio]{\Esei gestore_led_entity.png}
\end{figure}
\clearpage
È realizzato come una macchina a stati che gestisce la visualizzazione degli output, visualizzandoli ad intervalli di 1s. Il generic N permette di gestire, tramite una variabile count, l’intervallo di visualizzazione degli output. Il generic X permette di stabilire, tramite la variabile count\_valori, il numero di valori da visualizzare.
\begin{figure}[ht!]
    \includegraphics[width=0.6\textwidth,height=\textheight,keepaspectratio]{\Esei gestore_led_archit1.png}
\end{figure}
\begin{figure}[ht!]
    \includegraphics[width=0.75\textwidth,height=\textheight,keepaspectratio]{\Esei gestore_led_archit2.png}
    \caption{Gestore Led}
\end{figure}
\clearpage
Lista di stati:
\begin{itemize}
    \item Stato q0: è lo stato in cui si arriva dopo ogni segnale di RESET o dopo la visualizzazione completa dei valori in memoria. Vengono resettati i valori di count, count\_valori e si rimane in attesa di un segnale di READ per poter passare allo stato q\_ready.
    \item Stato q\_ready: si confronta il valore di count\_valori con 0 per poter stabilire se è la prima iterazione, in questo caso si aspetta che la macchina elabora i dati in ingresso per poi passare alla visualizzazione effettiva, altrimenti si alza il segnale di lettura della memoria. Si incrementa, poi, il valore di count\_valori e si passa allo stato q\_ready2.
    \item Stato q\_ready2: si abbassa il segnale di lettura della memoria e si mostrano i risultati, attendendo un numero di impulsi di clock pari ad N tramite la variabile count, prima di procedere alla visualizzazione del risultato successivo. Si effettua, poi, un controllo per stabilire se il valore visualizzato è l’ultimo o meno tramite count\_valori: se è così, allora si passa allo stato di q0;  altrimenti si passa in q\_ready.
\end{itemize}
\subsection{Simulazione e Sinstesi}
Simulazione:
\begin{figure}[ht!]
    \centering
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Esei simulazione.png}
    \caption{Simulazione Es.6}
\end{figure}
\clearpage
Sintesi su FPGA:
\\Per la sintesi su fpga sono stati inseriti i debouncer per i pulsanti di READ e RESET.
\begin{figure}[ht!]
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Esei board.jpg}
    \caption{Sintesi Es.6}
\end{figure}
\clearpage
\section{Esercizio 7 - Comunicazione Handshaking}
\subsection{Introduzione all'handshaking}
Nella comunicazione tra due entità, generalmente, si individua un’entità che trasmette i dati, chiamata master, ed un’entità che riceve ed elabora i dati, chiamata slave. Per far interagire correttamente il master e lo slave bisogna prendere in considerazione 2 fattori: la presenza o meno di un criterio di asservimento e la definizione di un criterio di riferimento temporale.
Quando l’entità slave è completamente asservita all’entità master, quest’ultima non deve preoccuparsi dell’istante di tempo in cui inviare i dati, dato che l’entità slave sarà sempre pronta a ricevere nuovi dati. In questo caso, quindi, non vi è la necessità di introdurre alcun segnale aggiuntivo per instaurare una comunicazione, ma basterà immettere i dati sul canale (al più si può pensare di utilizzare un segnale di strobe per evidenziare l’effettiva presenza dei dati).
\\Tuttavia, non sempre tra 2 entità l’asservimento è assoluto, e dunque, bisogna assicurarsi che, quando l’entità master vuole iniziare una nuova trasmissione, l’entità slave sia a sua volta disponibile.
Oltre ad un problema di asservimento, in genere, sussiste un problema di riferimento temporale, il quale nasce quando le 2 entità che devono interagire si trovano su 2 schede differenti, e dunque non possono essere fatte considerazioni sui riferimenti temporali. Infatti, anche se le 2 schede presentano clock isofrequenziali, non è detto che i riferimenti temporali siano analoghi, dato che questi possono variare per via alla fase iniziale.
Al fine di risolvere queste problematiche e garantire una corretta comunicazione tra 2 entità, si utilizza un protocollo di comunicazione basato su handshaking, che nel senso letterale indica una “stretta di mano” prima di avviare la comunicazione, il quale si basa sull’ipotesi che sia sempre il master ad inviare dati sul canale.
\\Di un protocollo basato su handshaking vi sono più implementazioni, le quali differiscono per le modalità di inizio della comunicazione e, di conseguenza, per il numero di segnali trasmessi sul canale.
Il protocollo più semplice è quello che prevede un segnale strobe da parte del master, che, come detto, evidenzia la presenza di dati sul canale, ed un segnale di risposta (generalmente chiamato di acknowledgment) da parte dello slave, il quale indica la corretta ricezione dei dati e può essere inviato sia appena ricevuti i dati, sia dopo la loro elaborazione.
Una implementazione di questo tipo è utile per risolvere un problema di riferimento temporale, ma può non essere adatta a comunicazione prive di asservimento, per le quali generalmente si fa uso di un protocollo basato su handshake interlacciato.
\\L’handshaking interlacciato prevede la verifica della disponibilità dello slave alla ricezione di nuovi dati, prima di immettere quest’ultimi sul canale. In tale implementazione, quando il master vuole inviare dei dati, prima invia un segnale di request allo slave, il quale, se disponibile, invia a sua volta un segnale di risposta. A questo punto parte la comunicazione.
Un ulteriore protocollo di handshaking, definito semisincrono, viene utilizzato quando lo slave deve inviare un dato di risposta al master, e prevede un ulteriore segnale per indicare quando l’elaborazione è terminata ed il dato di risposta è effettivamente presente sul canale. Si parla di protocollo semi sincrono poiché, il master, vede il segnale solo in corrispondenza di un colpo di clock (un protocollo di questo tipo è generalmente implementato nella comunicazione tra il processore e la memoria cache).
\\Come detto all’inizio della trattazione, in genere il master e lo slave lavorano con 2 clock differenti: un protocollo di handshaking prevede che, la frequenza del riferimento temporale dello slave, sia N volte quella del master, in modo da riuscire a campionare il segnale ricevuto anche nel caso di sfasamenti del clock.
Entrando ora nel merito dell’esercizio, si è deciso di implementare un protocollo con handshaking di tipo semisincrono.
\\\\{\large \textbf{Approccio Utilizzato}}
\\L’esercizio in esame prevede 2 sistemi, A e B, dove il sistema A deve inviare N valori al sistema B il quale, a sua volta, dovrà sommare tali valori a quelli contenuti in memoria per poi salvare il risultato in ulteriori locazioni della memoria stessa.
Entrambi i sistemi sono stati definiti mediante un approccio strutturale, dove l’elemento principale è l’interfaccia dei 2 sistemi, la quale è responsabile dell’implementazione del protocollo di handshaking. Prima di passare alla descrizione dei 2 sistemi, nel paragrafo successivo verrà descritto il protocollo di handshaking implementato.
\\\\{\large \textbf{Descrizione Protocollo}}
\\Il protocollo di handshaking implementato prevede un segnale r, ovvero di request, alzato dal sistema A (il master), il quale indica la volontà di trasmettere dei dati, ed un segnale di ris, alzato dal sistema B(lo slave) in ricezione del segnale di request, che indica la disponibilità nel ricevere i dati e che rimarrà alto fino alla completa elaborazione di quest’ultimi.
La variazione da 1 a 0 del segnale di ris indica, dunque, la completa elaborazione dei dati da parte dello slave e viene interpretata dal master come la possibilità di inoltrare nuovi dati.
L’handshake avviene prima della trasmissione di ogni dato.
Vediamo ora come i 2 sistemi implementano tale protocollo.
\begin{figure}[ht!]
    \centering
    \includesvg[width=\textwidth,height=\textheight]{\Esette sistema_completo.svg}
    \caption{Schema Sistema Completo Es.7}
\end{figure}
\clearpage
%{\large \textbf{SistemaA:}}
\subsection{Sistema A}
Come precedentemente detto, il sistemaA è stato definito tramite un approccio strutturale, utilizzando i seguenti componenti:
\begin{itemize}
    \item Una memoria ROM dove vengono salvati i valori X(i);
    \item Un'interfaccia per effettuare l'handshaking e la trasmissione;
    \item Un contatore che segna il numero di comunicazioni già avvenute.
\end{itemize}
L’interfaccia rappresenta la parte di controllo mentre il contatore e la rom compongono la parte operativa.
\begin{figure}[ht!]
    \centering
    \includesvg[width=0.9\textwidth,height=\textheight]{\Esette sistema_a.svg}
    \caption{Schema Sistema A Es.7}
\end{figure}
\\Il sistema ripete la stessa sequenza di operazioni per ogni valore X(i) contenuto in ROM.
\\Alla comunicazione i-esima, l'interfaccia invia un segnale di read per leggere il valore X(i) puntato dal valore del contatore. Una volta letto il valore, l'interfaccia pone in uscita i dati per iniziare la nuova comunicazione e alza il segnale di R; abbassa tale segnale solo dopo l'arrivo del RIS. Finchè RIS resta alto, il sistema A non può iniziare una nuova comunicazione, per questo rimane in attesa che il ricevitore finisca di elaborare i dati, cioè che RIS si abbassi. Appena RIS = 0 allora posso iniziare la nuova comunicazione i+1.
\\Appena si raggiungono le N comunicazioni il segnale di DIV in uscita al contatore si alza e termina la comunicazione complessiva tra il sistema A e B dal lato del trasmettitore.
\clearpage
\subsubsection{Unità Operativa A}
{\large \textbf{Componente contatore:}}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Esette entity_contatore.png}
    \caption{Entity Contatore}
\end{figure}
\\E' descritto come una macchina a stati che conta il numero di comunicazioni effettuate. A partire da un segnale di ris, il contatore conta quante volte questo si alza, ossia i fronti di salita:
\begin{enumerate}
    \item q0 $\rightarrow$ stato in cui se il segnale in ingresso al contatore è basso allora resto in q0, altrimenti effettuo l'incremento del contatore in modulo N e mi sposto nello stato q1. Se raggiungo la fine del conteggio ossia count = N-1 allora alzo DIV (segnale di stop).
    \item q1 $\rightarrow$ stato in cui aspetto che il segnale in ingresso si abbassi: se rimane alto, allora resto in q1, altrimenti passo in q0;
\end{enumerate}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.8\textwidth,height=\textheight,keepaspectratio]{\Esette architecture_counter.png}
    \caption{Architecture Contatore}
\end{figure}
\clearpage
{\large \textbf{Componente Rom:}}
\begin{figure}[ht]
    \centering
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Esette entity_rom.png}
\end{figure}
\\E' progettato come una semplice memoria, che sul fronte di salita del clock valuta il segnale di read: se questo è alto, pone in uscita il dato presente alla locazione indicata dal valore del counter.
\begin{figure}[ht!]
    \centering
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Esette architecture_rom.png}
    \caption{Architecture ROM}
\end{figure}
\clearpage
\subsubsection{Unità di Controllo A}
{\large \textbf{Componente interfaccia:}}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Esette entity_interfacciaa.png}
    \caption{Entity Interfaccia A Es.7}
\end{figure}
\\L’interfaccia è il componente che gestisce l’handshaking e la trasmissione dei dati sul canale. È stata progettata come una macchina a 7 stati, dove:
\begin{enumerate}
    \item q0 $\rightarrow$ è lo stato iniziale, dove ci si ritrova prima della trasmissione oppure al termine. Per distinguere i 2 casi si utilizza il segnale di div in uscita dal contatore: quando è basso, indica che ancora non abbiamo trasferito il primo dato (dato che differenziamo la prima trasmissione dalle altre e, dunque, in q0 si valuta solo la prima), mentre, quando è alto, indica che tutti i dati sono stati trasmessi e si permane indefinitamente in q0.
          Quando il segnale di div è basso, si passa il q1 e viene alzato il segnale di read, in modo da leggere dalla memoria il valore da trasmettere.
    \item q1 $\rightarrow$ viene abbassato il segnale di read, dato che deve durare solo 1 colpo di clock, al fine di evitare letture spurie in memoria. Si passa poi nello stato q2.
          Anche se può sembrare superfluo, lo stato q1 è necessario, per dare il tempo al componente memoria di porre in uscita il dato i-esimo.
    \item q2 $\rightarrow$ siamo ora sicuri che il dato in uscita dalla memoria è quello corretto: possiamo dunque riporlo sul canale ed alzare il segnale r. Si passa ora nello stato q3.
    \item q3 $\rightarrow$ tale stato è sostanzialmente di attesa: finchè non si alza il segnale di ris in ingresso, si permane in q3. Quando invece tale segnale viene rilevato come alto, i dati sono stati acquisiti dal sistemaB e si può passare dunque allo stato q4.
    \item q4 $\rightarrow$ quando ci si ritrova in questo stato, si è sicuri che il sistemaB ha ricevuto i dati inviati: si abbassa dunque il segnale di r e si passa allo stato q5.
    \item q5 $\rightarrow$ tale stato è sostanzialmente analogo a q0, solo che viene utilizzato per le trasmissioni successive alla prima. Si valuta quindi il segnale di div e, se alto, si procede verso q0, altrimenti si alza il segnale di read e si procede verso q6. È bene notare che, tali controlli sul segnale di div, potevano essere fatti anche in q4; tuttavia, dato che il contatore si incrementa sul segnale di ris in ingresso al sistema, si è preferito aggiungere uno stato per essere sicuri di vedere tale segnale stabile.
    \item q6 $\rightarrow$ se ci ritroviamo in questo stato, vuol dire che si deve procedere ad una trasmissione successiva alla prima. Per questo motivo si controlla il segnale di ris: se questo è basso, allora la precedente elaborazione è terminata e si può procedere ad inviare i nuovi dati, passando allo stato q2, mentre, se alto, si permane in q6 in attesa che si abbassi.
\end{enumerate}
\clearpage
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.55\textwidth,height=\textheight,keepaspectratio]{\Esette arc_inta_1.png}
\end{figure}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.55\textwidth,height=\textheight,keepaspectratio]{\Esette arc_inta_2.png}
    \caption{Architecture Interfaccia A Es.7}
\end{figure}
\clearpage
\subsection{Sistema B}
Il Sistema B è stato definito tramite un approccio strutturale, utilizzando i seguenti componenti:
\begin{itemize}
    \item Un’interfaccia, la quale comunica con il sistema A, gestisce i segnali di r e ris e acquisisce i dati da elaborare;
    \item Un contatore per indicare la terminazione dei dati da ricevere;
    \item Una control unit, che ha il compito di effettuare le operazioni sui dati ricevuti e di salvarli in memoria;
    \item Una memoria unica con i dati da sommare a quelli ricevuti dal sistema A e ulteriori locazioni per salvare i risultati.
\end{itemize}
Anche per tale sistema, l’interfaccia rappresenta la parte di controllo mentre la memoria, il contatore e la control unit compongono la parte operativa. Il nome control-unit può risultare confusionale, ma è stato dato poiché elabora i dati e controlla il componente memoria.
\begin{figure}[ht!]
    \centering
    \includesvg[width=0.9\textwidth,height=\textheight]{\Esette sistema_b.svg}
    \caption{Schema Sistema B Es.7}
\end{figure}
\clearpage
\subsubsection{Unita Operativa B}
{\large \textbf{Componente Control Unit:}}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.55\textwidth,height=\textheight,keepaspectratio]{\Esette entity_controlunitb.png}
    \caption{Entity Control Unit}
\end{figure}
\\La control unit è responsabile dell’elaborazione dei dati ricevuti e della collocazione dei risultati all’interno della memoria. Anch’essa è stata definita come una macchina a stati, dove:
\begin{enumerate}
    \item q0 $\rightarrow$ è lo stato in cui la macchina permane fino alla ricezione del primo dato da elaborare, rimanendo in attesa della variazione da 0 a 1 del segnale di ab\_control modificato dall’interfaccia.
          Quando rileva tale variazione passa allo stato q1 ed abbassa l’ab\_interfaccia.
    \item q1 $\rightarrow$ in tale stato si ripone il segnale di read a 1  e si passa allo stato q2.
    \item q2 $\rightarrow$ dato che il segnale di read si vuole che duri un singolo colpo di clock, in questo stato viene abbassato e si passa poi allo stato q3.
    \item q3 $\rightarrow$ in tale stato si è sicuri che i dati da elaborare sono entrambi disponibili e corretti, motivo per cui vengono immagazzinati come unsigned all’interno di appositi signal, tramite i quali si eseguirà poi una operazione di somma. In questo stato si pone a 1 il segnale di ab\_interfaccia, il quale verrà letto al colpo di clock dopo dall’interfaccia che abbasserà il segnale di ris. Anche se l’elaborazione non è del tutto terminata, si inizia a dare tale segnale dato che al colpo di clock dopo si avrà effettivamente la completa elaborazione e, comunque, il segnale ab\_interfaccia verrà rilevato al colpo di clock successivo. Si passa infine allo stato q4.
    \item q4 $\rightarrow$ viene alzata la write e posto sul segnale s il valore della somma, il quale verrà salvato nella memoria; si pone inoltre a 0 il segnale di ab\_interfaccia. Quest’ultima operazione può risultare ambigua, dato che porre a 0 tale segnale vuol dire disabilitare l’interfaccia, che in questo caso però deve essere attiva e pronta a ricevere ed inoltrare nuovi dati. Ciò che è bene notare, però, è che l’interfaccia valuta il segnale di ab\_interfaccia solo in alcuni stati e, la variazione di tale segnale permette comunque di proseguire verso alcuni stati, ma la mette in attesa negli stati in cui è giusto che l’interfaccia si fermi una volta ricevuti i dati. Stiamo sostanzialmente dicendo all’interfaccia che, quando arriverà nuovamente in uno di quegli stati dovrà fermarsi e non che in generale non deve lavorare. Si passa infine allo stato q5.
    \item q5 $\rightarrow$ tale stato ha sostanzialmente lo stesso scopo dello stato q4 nell’interfaccia, ovvero quello di replicare lo stato q0 quando però non si è al primo dato da elaborare. Le operazioni sono dunque analoghe a quelle dello stato q0, con l’aggiunta della variazione da 1 a 0 del segnale di write, il quale, come il segnale di read, deve durare 1 colpo di clock.
\end{enumerate}
\clearpage
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.55\textwidth,height=\textheight,keepaspectratio]{\Esette arc_control_b1.png}
\end{figure}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.55\textwidth,height=\textheight,keepaspectratio]{\Esette arc_control_b2.png}
    \caption{Entity Control Unit}
\end{figure}
\clearpage
{\large \textbf{Componente Counter:}}
\\Tale contatore è impostato sul fronte di salita del clock e incrementa solo quando il segnale di ab\_interfaccia si alza, ovvero quando è terminata l’elaborazione del dato. Siccome tale segnale si alza un colpo di clock prima dell’effettiva terminazione, è stato introdotto un blocco di delay per salvare i valori nella giusta locazione di memoria.
\\Tale componente è analogo al contatore utilizzato nel sistema A, ovvero progettato come una macchina a stati; varia solamente il segnale che riceve in ingresso.
\\\\{\large \textbf{Componente Memoria:}}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Esette entity_memoriab.png}
\end{figure}
\\Tale componente è stato descritto in modo comportamentale ed è uguale al componente utilizzato nell’esercizio 5. Tuttavia, per completezza, riportiamo nuovamente la sua implementazione.
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.75\textwidth,height=\textheight,keepaspectratio]{\Esette architecture_memoriab.png}
    \caption{Architecture Memoria B}
\end{figure}
\clearpage
\subsubsection{Unità di controllo}
{\large \textbf{Componente Interfaccia:}}
\begin{figure}[ht]
    \centering
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Esette entity_interfacciab.png}
    \caption{Interfaccia B}
\end{figure}
L’interfaccia è stata definita come una macchina a 5 stati, dove:
\begin{enumerate}
    \item q0 $\rightarrow$ E' lo stato in cui si trova l’interfaccia prima di ricevere il primo dato da elaborare. In questo stato, si attende la variazione del dato in input r, ricevuto dal sistema A, la cui variazione da 0 a 1 indica la disponibilità dei dati da elaborare. Finché r è basso, l’interfaccia permane in q0 e, quando rileva la variazione sul fronte di salita del clock, acquisisce i dati, alza il segnale di ris in uscita ( il quale viene visto dal sistema A ed è indice che i dati sono stati prelevati e che l’elaborazione di B è iniziata) ed abilita il segnale di ab\_control, che mette in attesa l’interfaccia stessa durante l’elaborazione dei dati da parte della control unit. Passa infine nello stato q1.
    \item q1 $\rightarrow$ In tale stato l’interfaccia permane finché non vede una variazione da 0 a 1 del segnale ab\_interfaccia, il quale viene fatto variare dalla control unit una volta terminata l’elaborazione dei dati ricevuti. Quando viene rilevata la variazione su tale segnale, l’interfaccia abbassa il segnale ab\_control, disabilitando così la control unit fino alla ricezione di nuovi dati. Passa infine nello stato q2.
    \item q2 $\rightarrow$ La prima operazione che si effettua in questo stato è la valutazione del segnale r, verificando se questo è ancora alto o meno. Tale operazione potrebbe risultare inutile, dato che il sistema A abbassa tale segnale nel momento in cui vede il segnale di ris alzarsi, ma così non è. Bisogna ricordare infatti che il sistema B lavora in genere con un clock a frequenza maggiore (o semplicemente con fase diversa) e potrebbe quindi svolgere le operazioni in maniera molto rapida e non dare il tempo al sistema A di abbassare tale segnale. Se non venisse effettuato tale controllo, negli stati successivi si potrebbe interpretare il segnale di r pari ad 1 come indice di nuova trasmissione, portando alla rielaborazione di dati già processati.
          \\L’interfaccia pertanto rimane in tale stato finché non rileva una variazione da 1 a 0 del segnale di r; quando tale segnale varia, abbassa il segnale di ris e passa nello stato q3.
          \\Valutare il segnale r prima di abbassare quello di ris risolve inoltre un altro problema: dato che il segnale di ris viene valutato dal sistemaA, così facendo, si fa in modo che duri almeno 1 colpo di clock di A, in modo che quest’ultimo possa rilevarne le variazioni, indipendentemente dal numero di operazioni effettuate dal sistema B.
    \item q3 $\rightarrow$ Tale stato è il responsabile del controllo dei dati rimanenti da elaborare. Se il segnale di div in uscita dal contatore è alto, allora vuol dire che il dato appena elaborato era l’ultimo e l’interfaccia torna dunque nello stato q0. In caso contrario si procede verso lo stato q4.
    \item q4 $\rightarrow$ Questo stato è sostanzialmente l’analogo dello stato q0, ma quando si sono già ricevuti dei dati.  È necessario introdurre questo tipo di stato per effettuare un controllo sul numero di elaborazioni effettuate per determinare la terminazione di esse.
\end{enumerate}
\clearpage
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.65\textwidth,height=\textheight,keepaspectratio]{\Esette arc_inter_b1.png}
\end{figure}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.45\textwidth,height=\textheight,keepaspectratio]{\Esette arc_inter_b2.png}
    \caption{Architecture Interfaccia B Es.7}
\end{figure}
\clearpage
\subsection{Considerazioni Finali}
Per come è stato implementato, il protocollo è efficiente con $f_B=N \cdot f_A$ per ogni valore di N (si da per scontato che il clock di B permette l’assestamento dei segnali in 1 colpo di clock).
\\In questo modo, non serve che il componente master ed il componente slave si accordino sulle frequenze da utilizzare.
\\Nel caso in cui siano noti i riferimenti temporali dei 2 componenti, possono essere ridotti il numero di stati delle interfacce di A e di B.
\\\\{\large \textbf{Simulazione:}}
\\Così come richiesto, è stata effettuata una simulazione del funzionamento del protocollo, con una frequenza $f_B=2 \cdot f_A:$
\begin{figure}[ht!]
    \centering
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Esette sim1.png}
\end{figure}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{\Esette sim2.png}
    \caption{Simulazione Es.7}
\end{figure}
\newpage
\section{Esercizio 8 - Processor}
\newpage
\section{Esercizio 9 - Interfaccia UART}
\newpage
\section{Esercizio 10 - Switch Multistadio}
\newpage
\section{Esercizio 11 - Divisore Restoring}
\newpage
\section{Esercizio 12 - Interfaccia VGA}

\newpage
\listoffigures
\end{document}